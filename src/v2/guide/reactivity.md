---
title: Подробно о реактивности
type: guide
order: 12
---

Мы&nbsp;уже разобрали большую часть основ, так что пришло время нырнуть поглубже! Одна из&nbsp;наиболее примечательных возможностей Vue&nbsp;&mdash; это ненавязчивая реактивность. Модели представляют собой простые JavaScript-объекты. По&nbsp;мере их&nbsp;изменения обновляется и&nbsp;представление данных, благодаря чему управление состоянием приложения становится простым и&nbsp;очевидным. Тем не&nbsp;менее, у&nbsp;механизма реактивности есть ряд особенностей, знакомство с&nbsp;которыми позволит избежать распространенных ошибок. В&nbsp;этом разделе руководства мы&nbsp;подробно рассмотрим низкоуровневую реализацию системы реактивности Vue.

## Как отслеживаются изменения


Когда простой JavaScript-объект передаётся в&nbsp;инстанс Vue в&nbsp;качестве опции `data`, Vue обходит все его поля и&nbsp;превращает их&nbsp;в&nbsp;пары геттер/сеттер, используя [Object.defineProperty](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/defineProperty). Эта возможность появилась в&nbsp;JavaScript только начиная с&nbsp;версии ES5, и&nbsp;в&nbsp;более ранних версиях её&nbsp;эмулировать не&nbsp;получится&nbsp;&mdash; по&nbsp;этой-то причине Vue и&nbsp;не&nbsp;поддерживает IE8 и&nbsp;ниже.

Геттеры и&nbsp;сеттеры не&nbsp;видны пользователю, но&nbsp;именно они являются тем внутренним механизмом, который позволяет Vue отслеживать зависимости и&nbsp;изменения данных. К&nbsp;сожалению, при таком подходе выведенные в&nbsp;консоль браузера геттеры и&nbsp;сеттеры выглядят не&nbsp;так, как обычные объекты, поэтому для более наглядной визуализации лучше использовать [инструменты разработчика Vue-devtools](https://github.com/vuejs/vue-devtools).

К&nbsp;каждому инстансу компонента приставлен связанный с&nbsp;ним **инстанс наблюдателя**, который помечает все поля, затронутые при рендеринге компонента, как зависимости. В&nbsp;дальнейшем, когда вызывается сеттер поля, помеченного как зависимость, этот сеттер уведомляет наблюдателя, который в&nbsp;свою очередь инициирует повторный рендеринг компонента.

![Цикл реактивности](/images/data.png)

## Особенности отслеживания изменений

В&nbsp;силу ограничений современного JavaScript (и&nbsp;отказа от `Object.observe`), Vue **не&nbsp;может отследить добавление или удаление свойства объекта**. Чтобы поле стало реактивным, Vue превращает его пару геттер/сеттер в&nbsp;ходе инициализации инстанса. Поэтому все поля должны изначально быть заданы в&nbsp;объекте `data`. Например:

``` js
var vm = new Vue({
  data: {
    a: 1
  }
})
// теперь `vm.a` — реактивное поле

vm.b = 2
// `vm.b` НЕ реактивно
```

Во&nbsp;Vue нельзя динамически добавлять новые корневые реактивные свойства в&nbsp;уже существующий инстанс. Тем не&nbsp;менее, можно добавить реактивное свойство во&nbsp;вложенные объекты, используя метод `Vue.set(object, key, value)`:

``` js
Vue.set(vm.someObject, 'b', 2)
```

Также можно использовать метод инстанса `vm.$set`, который представляет собой псевдоним к&nbsp;глобальному `Vue.set`:

``` js
this.$set(this.someObject, 'b', 2)
```

Иногда нужно добавить несколько свойств в&nbsp;существующий объект, например, с&nbsp;помощью `Object.assign()` или `_.extend()`. Если так поступить, добавленные свойства не&nbsp;станут реактивными. Для решения этой задачи придется создать новый объект, содержащий поля как оригинального объекта, так и&nbsp;объекта-примеси:

``` js
// вместо `Object.assign(this.someObject, { a: 1, b: 2 })`
this.someObject = Object.assign({}, this.someObject, { a: 1, b: 2 })
```

Существует также несколько ограничений, связанных с&nbsp;массивами. Их&nbsp;мы&nbsp;рассмотрели ранее в&nbsp;[разделе об&nbsp;отображении списков](list.html#Предостережения).

## Объявление реактивных свойств

Поскольку Vue не&nbsp;позволяет динамически добавлять корневые реактивные свойства, это означает, что все корневые поля необходимо инициализировать изначально, хотя&nbsp;бы пустыми значениями:

``` js
var vm = new Vue({
  data: {
    // объявляем поле message, содержащее пустую строку
    message: ''
  },
  template: '<div>{{ message }}</div>'
})
// впоследствии задаём значение `message`
vm.message = 'Hello!'
```

Если не&nbsp;задать поле `message` в&nbsp;опции data, Vue выведет предупреждение, что функция рендеринга пытается получить доступ к&nbsp;несуществующему свойству.

Существуют технические причины для этого ограничения: оно позволяет исключить целый класс граничных случаев в&nbsp;системе учёта зависимостей, а&nbsp;также упростить взаимодействие Vue с&nbsp;системами проверки типов. Но&nbsp;более важно&nbsp;то, что с&nbsp;этим ограничением становится проще поддерживать код, так как теперь объект `data` можно рассматривать как схему состояния компонента. Код, в&nbsp;котором реактивные свойства компонента перечислены заранее, намного проще для понимания.

## Асинхронная очередь обновлений

На&nbsp;всякий случай напомним, что во&nbsp;Vue обновление DOM выполняется **асинхронно**. Каждый раз, когда обнаруживается изменение в&nbsp;данных, создаётся очередь, которая используется в&nbsp;качестве буфера для этого и&nbsp;последующих изменений, происходящих в&nbsp;текущей итерации (&laquo;tick&raquo;) цикла событий. Если один и&nbsp;тот&nbsp;же наблюдатель срабатывает несколько раз, в&nbsp;очередь он&nbsp;попадёт всё равно лишь единожды. Благодаря использованию буфера и&nbsp;устранению дубликатов, вычисления и&nbsp;манипуляции DOM сводятся к&nbsp;минимуму. В&nbsp;следующей итерации цикла событий Vue разбирает очередь и&nbsp;выполняет актуальные (уже не&nbsp;содержащие дубликатов) обновления. На&nbsp;низком уровне для асинхронной постановки задач в&nbsp;очередь используются `Promise.then` и&nbsp;`MutationObserver`, а&nbsp;если они недоступны, то&nbsp;`setTimeout(fn, 0)`.

Итак, если выполнить код `vm.someData = 'new value'`, компонент не&nbsp;будет перерендерен сразу&nbsp;же. Он&nbsp;обновится в&nbsp;следующей итерации при разборе очереди. Чаще всего эту особенность можно не&nbsp;принимать в&nbsp;расчёт, но&nbsp;иногда бывает нужно дождаться состояния, в&nbsp;которое DOM перейдёт после обновления данных. Хотя прямая манипуляция DOM нежелательна, а&nbsp;системы в&nbsp;целом предпочтительнее проектировать так, чтобы в&nbsp;них были первичны данные, иногда всё&nbsp;же её&nbsp;не&nbsp;избежать. Чтобы выполнить какой-нибудь код только после того, как завершится обновление DOM, можно передать коллбэк в&nbsp;метод `Vue.nextTick(callback)` после изменения данных. Он&nbsp;будет вызван после обновления DOM. Например:

``` html
<div id="example">{{ message }}</div>
```

``` js
var vm = new Vue({
  el: '#example',
  data: {
    message: '123'
  }
})
vm.message = 'новое сообщение' // изменяем данные
vm.$el.textContent === 'новое сообщение' // false
Vue.nextTick(function () {
  vm.$el.textContent === 'новое сообщение' // true
})
```

Существует также метод инстанса `vm.$nextTick()`, особенно подходящий для использования внутри компонентов, поскольку он&nbsp;не&nbsp;требует обращения к&nbsp;глобальной переменной `Vue`, а&nbsp;также автоматически связывает контекст `this` коллбэка с&nbsp;текущим инстансом Vue:

``` js
Vue.component('example', {
  template: '<span>{{ message }}</span>',
  data: function () {
    return {
      message: 'не обновлено'
    }
  },
  methods: {
    updateMessage: function () {
      this.message = 'обновлено'
      console.log(this.$el.textContent) // => 'не обновлено'
      this.$nextTick(function () {
        console.log(this.$el.textContent) // => 'обновлено'
      })
    }
  }
})
```
