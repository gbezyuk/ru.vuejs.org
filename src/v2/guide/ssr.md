---
title: SSR. Рендеринг на стороне сервера
type: guide
order: 24
---

## Нужен ли вам SSR?

Перед тем как углубляться в&nbsp;SSR, давайте разберёмся, что это за&nbsp;технология, и&nbsp;когда она может вам понадобиться.

### SEO

Google и&nbsp;Bing прекрасно индексируют синхронные JavaScript-приложения. _Синхронные_ здесь&nbsp;&mdash; ключевое слово. Если ваше приложение начинается с&nbsp;индикатора загрузки, подгружая данные с&nbsp;помощью ajax-запросов, поисковый робот ждать окончания загрузки не&nbsp;станет.

Это означает, что если данные загружаются асинхронно на&nbsp;страницах, для которых важна оптимальная индексация поисковиками, SSR может стать необходимостью.

### Клиенты с медленным соединением

Пользователи могут приходить на&nbsp;ваш сайт из&nbsp;отдалённых районов с&nbsp;медленным соединением&nbsp;&mdash; или&nbsp;же просто через медленный мобильный интернет. В&nbsp;таких случаях лучше минимизировать количество и&nbsp;объём запросов, требующихся для отображения основного контента.

Во&nbsp;избежания загрузки целого приложения можно использовать [инструменты Webpack для разделения кода](https://webpack.github.io/docs/code-splitting.html), но&nbsp;даже этот подход не&nbsp;будет столь&nbsp;же эффективен, как скачивание уже готового отрендеренного на&nbsp;сервере файла.

### Клиенты с устаревшим JavaScript (или вовсе без такового)

В&nbsp;некоторых демографических группах и&nbsp;отдельных регионах единственной опцией для доступа в&nbsp;интернет может оказаться компьютер 1998&nbsp;года. Несмотря на&nbsp;то, что Vue работает только с&nbsp;IE9+, возможно вам всё&nbsp;же понадобится возможность доставить содержимое страниц в&nbsp;устаревшие браузеры&nbsp;&mdash; или хакерам-хипстерам, использующим [Lynx](http://lynx.browser.org/) в&nbsp;терминале.

### Пререндеринг

Если вы&nbsp;интересуетесь SSR только для того, чтобы улучшить SEO на&nbsp;нескольких маркетинговых страницах (напр. `/`, `/about`, `/contact` и&nbsp;т.д.), вам скорее всего будет достаточно __пререндеринга__. Вместо того чтобы заставлять веб-сервер компилировать HTML&nbsp;на лету, пререндеринг просто однократно строит статические HTML-файлы для указанных путей на&nbsp;этапе сборки. Преимущество пререндеринга&nbsp;&mdash; простота, кроме того этот подход позволяет вам оставить фронтенд полностью статичным.

Если вы&nbsp;используете Webpack, пререндеринг несложно добавить при помощи плагина [prerender-spa-plugin](https://github.com/chrisvfritz/prerender-spa-plugin). Плагин был серьёзнейшим образом протестирован с&nbsp;Vue (вообще-то, его создатель&nbsp;&mdash; член основной команды разработки Vue).

## Hello World

Если вы&nbsp;дочитали до&nbsp;этого места, пора посмотреть на&nbsp;SSR в&nbsp;действии. Звучит, конечно, сложновато, но&nbsp;для простой демонстрации нужно всего 3&nbsp;шага:

``` js
// Шаг 1: Создадим инстанс Vue
var Vue = require('vue')
var app = new Vue({
  render: function (h) {
    return h('p', 'hello world')
  }
})

// Шаг 2: Создадим рендерер
var renderer = require('vue-server-renderer').createRenderer()

// Шаг 3: Рендеринг инстанса в HTML
renderer.renderToString(app, function (error, html) {
  if (error) throw error
  console.log(html)
  // => <p server-rendered="true">hello world</p>
})
```

Не&nbsp;так уж&nbsp;страшно, правда? Конечно, этот пример намного проще чем большинство приложений. Нам не&nbsp;пришлось волноваться&nbsp;о:

- Веб-сервере
- Стриминге
- Кешировании компонентов
- Процессе сборки
- Роутинге
- Гидрировании состояния Vuex

В&nbsp;оставшейся части данного руководства мы&nbsp;пробежимся по&nbsp;некоторым из&nbsp;этих вещей. А&nbsp;когда вы&nbsp;поймёте основы, мы&nbsp;сможем направить вас к&nbsp;более детальной документации и&nbsp;более продвинутым примерам, включая рассмотрение краевых случаев.

## Простая реализация SSR на базе веб-сервера Express

Использование термина &laquo;рендеринг на&nbsp;сервере&raquo;, в&nbsp;отсутствии самого веб-сервера звучит натянуто&nbsp;&mdash; давайте это исправим. Мы&nbsp;создадим простейшее SSR-приложение, применяя только ES5 и&nbsp;не&nbsp;используя ни&nbsp;сборщиков, ни&nbsp;плагинов.

Начнём с&nbsp;приложения, которое просто сообщает пользователю сколько секунд он&nbsp;провёл на&nbsp;странице:

``` js
new Vue({
  template: '<div>Вы были здесь {{ counter }} секунд.</div>',
  data: {
    counter: 0
  },
  created: function () {
    var vm = this
    setInterval(function () {
      vm.counter += 1
    }, 1000)
  }
})
```

Чтобы приложение работало и&nbsp;на&nbsp;клиенте и&nbsp;на&nbsp;сервере, придётся внести несколько модификаций:

- Когда приложение запущено в&nbsp;браузере, нужно добавить инстанс приложения в&nbsp;глобальный контекст (т.е. `window`), чтобы была возможность впоследствии его смонтировать
- Когда приложение запущено на&nbsp;сервере, нужно экспортировать функцию-фабрику, которая будет создавать новое приложение для каждого запроса

Для этого потребуется немного дополнительного кода:

``` js
// assets/app.js
(function () { 'use strict'
  var createApp = function () {
    // ----------------------
    // Начало кода приложения
    // ----------------------

    // Необходимо вернуть основной инстанс Vue, а у корневого
    // элемента должен быть id "app", чтобы клиентская версия
    // смогла подхватить работу после загрузки
    return new Vue({
      template: '<div id="app">Вы были здесь {{ counter }} секунд.</div>',
      data: {
        counter: 0
      },
      created: function () {
        var vm = this
        setInterval(function () {
          vm.counter += 1
        }, 1000)
      }
    })

    // ---------------------
    // Конец кода приложения
    // ---------------------
  }
  if (typeof module !== 'undefined' && module.exports) {
    module.exports = createApp
  } else {
    this.app = createApp()
  }
}).call(this)
```

Теперь, когда у&nbsp;нас есть код приложения, давайте соберём файл `index.html`:

``` html
<!-- index.html -->
<!DOCTYPE html>
<html>
<head>
  <title>Моё приложение на Vue</title>
  <script src="/assets/vue.js"></script>
</head>
<body>
  <div id="app"></div>
  <script src="/assets/app.js"></script>
  <script>app.$mount('#app')</script>
</body>
</html>
```

Если упомянутая папка `assets` содержит файл нашего приложения `app.js`, и&nbsp;файл самого Vue `vue.js`, должно получится вполне рабочее одностраничное приложение!

Чтобы включить рендеринг на&nbsp;стороне сервера, остаётся добавить только собственно веб-сервер:

``` js
// server.js
'use strict'

var fs = require('fs')
var path = require('path')

// Получаем доступ к Vue глобально для серверной версии app.js
global.Vue = require('vue')

// Получаем HTML-шаблон
var layout = fs.readFileSync('./index.html', 'utf8')

// Создаём рендерер
var renderer = require('vue-server-renderer').createRenderer()

// Создаём Express-сервер
var express = require('express')
var server = express()

// Включаем отдачу статических файлов из директории assets
server.use('/assets', express.static(
  path.resolve(__dirname, 'assets')
))

// Обрабатываем все GET-запросы
server.get('*', function (request, response) {
  // Рендерим наше приложение в строку
  renderer.renderToString(
    // Создаём инстанс приложения
    require('./assets/app')(),
    // Обрабатываем результат рендеринга
    function (error, html) {
      // Если при перендеринге произошла ошибка...
      if (error) {
        // Логируем её в консоль
        console.error(error)
        // И говорим клиенту, что что-то пошло не так
        return response
          .status(500)
          .send('Server Error')
      }
      // Отсылаем HTML-шаблон, в который вставлен результат перендеринга приложения
      response.send(layout.replace('<div id="app"></div>', html))
    }
  )
})

// Слушаем 5000-й порт
server.listen(5000, function (error) {
  if (error) throw error
  console.log('Server is running at localhost:5000')
})
```

Всё готово! Вот [код приложения целиком](https://github.com/chrisvfritz/vue-ssr-demo-simple), на&nbsp;случай если вы&nbsp;захотите клонировать репозиторий и&nbsp;продолжить эксперименты. Когда вы&nbsp;запустите этот код локально, проверить что перендеринг на&nbsp;стороне сервера действительно работает можно будет кликнув правой кнопкой мышки на&nbsp;странице и&nbsp;выбрав `Просмотр исходного кода` (или подобный пункт). В&nbsp;`body` страницы вы&nbsp;увидите вот это:

``` html
<div id="app" server-rendered="true">Вы были здесь 0 секунд.</div>
```

вместо:

``` html
<div id="app"></div>
```

## Стриминг

Vue также поддерживает __потоковый__ перендеринг, являющийся предпочтительным для поддерживающих его веб-серверов. HTML&nbsp;в таком случае пишется в&nbsp;ответ сервера _в&nbsp;процессе генерации_, а&nbsp;не&nbsp;единым куском в&nbsp;конце. В&nbsp;результате запросы обслуживаются быстрее, а&nbsp;негативных побочных эффектов у&nbsp;этого подхода&nbsp;&mdash; просто нет.

Для того чтобы включить стриминг в&nbsp;нашем приложении, мы&nbsp;просто заменим блок `server.get('*', ...)` таким образом:

``` js
// Разделим HTML-шаблон на две части
var layoutSections = layout.split('<div id="app"></div>')
var preAppHTML = layoutSections[0]
var postAppHTML = layoutSections[1]

// Обрабатываем все GET-запросы
server.get('*', function (request, response) {
  // Рендерим наше приложение в поток
  var stream = renderer.renderToStream(require('./assets/app')())

  // Пишем в ответ сервера кусочек HTML, идущий до самого приложения
  response.write(preAppHTML)

  // По мере того, как рендерятся новые кусочки...
  stream.on('data', function (chunk) {
    // Пишем их в ответ сервера
    response.write(chunk)
  })

  // Когда рендеринг приложения завершён
  stream.on('end', function () {
    // Дописываем остаток HTML-шаблона и завершаем запись в поток
    response.end(postAppHTML)
  })

  // Если при рендеринге произошла ошибка...
  stream.on('error', function (error) {
    // Логируем её в консоль
    console.error(error)
    // И говорим клиенту, что что-то пошло не так
    return response
      .status(500)
      .send('Server Error')
  })
})
```

Как вы&nbsp;видите, по&nbsp;сравнению с&nbsp;предыдущей версией особо ничего не&nbsp;усложнилось, даже если вы&nbsp;раньше не&nbsp;сталкивались с&nbsp;потоками. Мы&nbsp;просто:

1. Создаём поток
2. Записываем в&nbsp;поток &laquo;открывающий&raquo; HTML
3. По&nbsp;мере готовности записываем в&nbsp;поток части отрендеренного приложения
4. Записываем в&nbsp;поток &laquo;закрывающий&raquo; HTML и&nbsp;завершаем поток
5. Обрабатываем ошибки

## Кеширование компонентов

SSR во&nbsp;Vue работает быстро, но&nbsp;можно ещё больше улучшить быстродействие, кешируя результаты рендеринга компонентов. Впрочем, важно понимать, что это&nbsp;&mdash; продвинутый механизм, поскольку кеширование неправильных компонентов (или правильных компонентов с&nbsp;неправильными ключами) может привести к&nbsp;ошибкам рендеринга приложения. В&nbsp;частном случае:

<p class="tip">Не&nbsp;следует кешировать компоненты, содержащие потомков, чьё состояние зависит от&nbsp;глобального (напр. от&nbsp;состояния хранилища Vuex). Если вы&nbsp;это сделаете, дочерние компоненты (а&nbsp;по&nbsp;сути&nbsp;&mdash; всё под-дерево целиком) тоже закешируются. Будьте особенно аккуратны с&nbsp;компонентами, принимающими слоты и/или дочерние компоненты.</p>

### Настройка

Не&nbsp;забывая о&nbsp;вышесказанном, вот как работает кеширование компонентов.

Во-первых, в&nbsp;перендерер нужно передать [объект кеша](https://www.npmjs.com/package/vue-server-renderer#cache). Вот простой пример, использующий [lru-cache](https://github.com/isaacs/node-lru-cache):

``` js
var createRenderer = require('vue-server-renderer').createRenderer
var lru = require('lru-cache')

var renderer = createRenderer({
  cache: lru(1000)
})
```

В&nbsp;этом примере мы&nbsp;позволяем кешировать до&nbsp;1000 уникальных рендеров. Для других конфигураций, более тонко оперирующих использованием оперативной памяти, см. [опции lru-cache](https://github.com/isaacs/node-lru-cache#options).

Далее, для компонентов, которые вы&nbsp;хотели&nbsp;бы кешировать, нужно указать:

- уникальное имя (`name`)
- функцию `serverCacheKey`, возвращающую уникальный ключ (в&nbsp;рамках компонента)

Например:

``` js
Vue.component({
  name: 'list-item',
  template: '<li>{{ item.name }}</li>',
  props: ['item'],
  serverCacheKey: function (props) {
    return props.item.type + '::' + props.item.id
  }
})
```

### Идеальные кешируемые компоненты

Любой &laquo;чистый&raquo; компонент можно безопасно кешировать. Чистыми считаются компоненты, гарантирующие рендеринг одинакового HTML для одних и&nbsp;тех&nbsp;же входных параметров. Типичными примерами являются:

- Статические компоненты (т.к. они всегда генерируют один и&nbsp;тот&nbsp;же HTML, так что функция `serverCacheKey` может всегда возвращать `true`)
- Компоненты элементов списков (для больших списков, кеширование элементов может значительно улучшить производительность)
- Общие компоненты&nbsp;UI (напр. кнопки, алерты и&nbsp;т.д. &mdash;&nbsp;по&nbsp;крайней мере&nbsp;те, что принимают контент через входные параметры, а&nbsp;не&nbsp;через слоты и/или дочерние элементы)

## Процесс сборки, роутинг и гидрация состояния Vuex

К&nbsp;этому моменту вы&nbsp;должны понимать основы рендеринга на&nbsp;сервере. Однако, при добавлении процесса сборки, роутинга и&nbsp;Vuex в&nbsp;картине появятся новые детали.

Если вы&nbsp;хотите действительно хорошо разобраться в&nbsp;SSR сложных приложений, мы&nbsp;советуем ознакомиться со&nbsp;следующими ресурсами:

- [документация vue-server-renderer](https://www.npmjs.com/package/vue-server-renderer#api): более подробно о&nbsp;том, о&nbsp;чём мы&nbsp;уже здесь говорили, а&nbsp;также по&nbsp;более продвинутым темам, таким как [предотвращение cross-request-загрязнения](https://www.npmjs.com/package/vue-server-renderer#why-use-bundlerenderer) и&nbsp;[добавление отдельной серверной сборки](https://www.npmjs.com/package/vue-server-renderer#creating-the-server-bundle)
- [vue-hackernews-2.0](https://github.com/vuejs/vue-hackernews-2.0): подробный пример, объединяющий все основные библиотеки и концепции Vue в единое приложение

## Nuxt.js

Правильно настроить все аспекты приложения с&nbsp;рендерингом на&nbsp;стороне сервера и&nbsp;готовое к&nbsp;развёртыванию на&nbsp;production может быть сложной задачей. К&nbsp;счастью, есть отличный проект сообщества, который стремится сделать всё проще: [Nuxt.js](https://nuxtjs.org/).

Nuxt.js&nbsp;&mdash; это высокоуровневый фреймворк, построенный на&nbsp;экосистеме Vue, что обеспечит быстрое получение опыта разработки универсальных приложений на&nbsp;Vue. И&nbsp;даже лучше, вы&nbsp;можете использовать его в&nbsp;качестве генератора статических сайтов (со&nbsp;страницами представленными однофайловыми компонентами)! Мы&nbsp;настоятельно рекомендуем попробовать его.

Кстати у него тоже есть [русская документация](https://ru.nuxtjs.org/)!
