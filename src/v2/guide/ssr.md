---
title: SSR. Рендеринг на стороне сервера
type: guide
order: 24
---

## Нужен ли вам SSR?

Перед тем как углубляться в SSR, давайте разберёмся, что это за технология, и когда она может вам понадобиться.

### SEO

Google и Bing прекрасно индексируют синхронные JavaScript-приложения. _Синхронные_ здесь — ключевое слово. Если ваше приложение начинается с индикатора загрузки, подтягивая данные Ajax-запросом, поисковый робот ждать окончания загрузки не станет.

Это означает, что если данные загружаются асинхронно на страницах, для которых SEO важно, SSR может стать необходимостью.

### Клиенты с медленным соединением

Пользователи могут приходить на ваш сайт из отдалённых районов с медленным соединением — или просто с медленного мобильного интернета. В таких случаях, будет лучше минимизировать количество и размер запросов, требующихся для отображения основного контента.

Во избежания загрузки целого приложения можно использовать [инструменты Webpack для разделения кода](https://webpack.github.io/docs/code-splitting.html), но даже этот подход не будет столь же эффективен, как скачивание уже готового срендеренного на сервере файла.

### Клиенты с устаревшим JavaScript (или вовсе без такового)

В некоторых сообществах и регионах единственной опцией для доступа в интернет может оказаться компьютер из 1998 года. Несмотря на то, что Vue работает только с IE9+, возможно вы всё же захотите иметь возможность доставить основной контент в устаревшие браузеры — или хакерам-хипстерам, использующим [Lynx](http://lynx.browser.org/) в терминале.

### Пререндеринг

Если вы интересуетесь SSR только для того, чтобы улучшить SEO на нескольких маркетинговых страницах (напр. `/`, `/about`, `/contact` и т.д.), вам скорее всего будет достаточно __пререндеринга__. Вместо того чтобы заставлять web-сервер компилировать HTML на лету, пререндеринг просто однократно строит статические HTML-файлы для указанных путей, на этапе сборки. Преимущество пререндеринга – в значительно большей простоте, кроме того этот подход позволяет вам оставить фронтенд полностью статичным.

Если вы используете Webpack, пререндеринг нетрудно добавить при помощи плагина [prerender-spa-plugin](https://github.com/chrisvfritz/prerender-spa-plugin). Плагин был серьёзнейшим образом протестирован с Vue (вообще-то, его создатель - член основной команды разработки Vue).

## Hello World

Если вы дочитали до этого места, пора посмотреть на SSR в действии. Звучит, конечно, сложновато, но для простой демонстрации нужно всего 3 шага:

``` js
// Шаг 1: Создадим инстанс Vue
var Vue = require('vue')
var app = new Vue({
  render: function (h) {
    return h('p', 'hello world')
  }
})

// Шаг 2: Создадим рендерер
var renderer = require('vue-server-renderer').createRenderer()

// Шаг 3: Рендеринг инстанса в HTML
renderer.renderToString(app, function (error, html) {
  if (error) throw error
  console.log(html)
  // => <p server-rendered="true">hello world</p>
})
```

Не так уж страшно, правда? Конечно, этот пример намного проще чем большинство приложений. Нам не пришлось волноваться о:

- Web-сервере
- Стриминге
- Кешировании компонентов
- Процессе сборки
- Роутинге
- Гидрировании состояния Vuex

В оставшейся части данного руководства мы пробежимся по некоторым из этих вещей. А когда вы поймёте основы, мы сможем направить вас к более детальной документации и более продвинутым примерам, включая рассмотрение краевых случаев.

## Простая реализация SSR на базе web-сервера Express

Использование термина "рендеринг на сервере", в отсутствии самого web-сервера звучит натянуто — давайте это исправим. Мы создадим простейшее SSR-приложение, применяя только ES5 и не используя ни сборщиков, ни плагинов.

Начнём с приложения, которое просто говорит пользователю, сколько секунд он провёл на странице:

``` js
new Vue({
  template: '<div>Вы были здесь {{ counter }} секунд.</div>',
  data: {
    counter: 0
  },
  created: function () {
    var vm = this
    setInterval(function () {
      vm.counter += 1
    }, 1000)
  }
})
```

Чтобы приложение работало и на клиенте и на сервере, придётся внести несколько модификаций:

- Когда приложение запущено в браузере, нужно добавить инстанс приложения в глобальный контекст (т.е. `window`), чтобы была возможность впоследствии его смонтировать
- Когда приложение запущено на сервере, нужно экспортировать функцию-фабрику, которая будет создавать новое приложение для каждого запроса

Для этого потребуется немного дополнительного кода:

``` js
// assets/app.js
(function () { 'use strict'
  var createApp = function () {
    // ----------------------
    // Начало кода приложения
    // ----------------------
    
    // Необходимо вернуть основной инстанс Vue, а у корневого
    // элемента должен быть id "app", чтобы клиентская версия
    // смогла подхватить работу после загрузки
    return new Vue({
      template: '<div id="app">Вы были здесь {{ counter }} секунд.</div>',
      data: {
        counter: 0
      },
      created: function () {
        var vm = this
        setInterval(function () {
          vm.counter += 1
        }, 1000)
      }
    })

    // ---------------------
    // Конец кода приложения
    // ---------------------
  }
  if (typeof module !== 'undefined' && module.exports) {
    module.exports = createApp
  } else {
    this.app = createApp()
  }
}).call(this)
```

Теперь, когда у нас есть код приложения, давайте соберём файл `index.html`:

``` html
<!-- index.html -->
<!DOCTYPE html>
<html>
<head>
  <title>Моё Приложение Vue</title>
  <script src="/assets/vue.js"></script>
</head>
<body>
  <div id="app"></div>
  <script src="/assets/app.js"></script>
  <script>app.$mount('#app')</script>
</body>
</html>
```

Если упомянутая папка `assets` содержит файл нашего приложения `app.js`, а равно и файл самого Vue, `vue.js`, должно получится вполне рабочее одностраничное приложение!

Чтобы включить рендеринг на стороне сервера, остаётся добавить только собственно web-сервер:

``` js
// server.js
'use strict'

var fs = require('fs')
var path = require('path')

// Получаем доступ к Vue глобально для серверной версии app.js
global.Vue = require('vue')

// Получаем HTML-шаблон
var layout = fs.readFileSync('./index.html', 'utf8')

// Создаём рендерер
var renderer = require('vue-server-renderer').createRenderer()

// Создаём Express-сервер
var express = require('express')
var server = express()

// Включаем отдачу статических файлов из директории assets
server.use('/assets', express.static(
  path.resolve(__dirname, 'assets')
))

// Обрабатываем все GET-запросы
server.get('*', function (request, response) {
  // Рендерим наше приложение в строку
  renderer.renderToString(
    // Создаём инстанс приложения
    require('./assets/app')(),
    // Обрабатываем результат рендеринга
    function (error, html) {
      // Если при рендеринге произошла ошибка...
      if (error) {
        // Логируем её в консоль
        console.error(error)
        // И говорим клиенту, что что-то пошло не так
        return response
          .status(500)
          .send('Server Error')
      }
      // Отсылаем HTML-шаблон, в который вставлен результат рендеринга приложения
      response.send(layout.replace('<div id="app"></div>', html))
    }
  )
})

// Слушаем 5000-й порт
server.listen(5000, function (error) {
  if (error) throw error
  console.log('Server is running at localhost:5000')
})
```

Всё готово! Вот [код приложения целиком](https://github.com/chrisvfritz/vue-ssr-demo-simple), на случай если вы захотите клонировать репозиторий и продолжить эксперименты. Когда вы запустите этот код локально, проверить что рендеринг на стороне сервера действительно работает можно будет кликнув правой кнопкой мышки на странице и выбрав `Просмотр исходного кода` (или подобный пункт). В body страницы вы увидите вот это:

``` html
<div id="app" server-rendered="true">Вы были здесь 0 секунд.&period;</div>
```

вместо:

``` html
<div id="app"></div>
```

## Стриминг

Vue также поддерживает __потоковый__ рендеринг, являющийся предпочтительным для поддерживающих его web-серверов. HTML в таком случае пишется в ответ сервера _в процессе генерации_, а не единым куском в конце. В результате запросы обслуживаются быстрее, а негативных побочных эффектов у этого подхода — просто нет.

Для того чтобы включить стриминг в нашем приложении, мы просто заменим блок `server.get('*', ...)` таким образом:

``` js
// Разделим HTML-шаблон на две части
var layoutSections = layout.split('<div id="app"></div>')
var preAppHTML = layoutSections[0]
var postAppHTML = layoutSections[1]

// Обрабатываем все GET-запросы
server.get('*', function (request, response) {
  // Рендерим наше приложение в поток
  var stream = renderer.renderToStream(require('./assets/app')())

  // Пишем в ответ сервера кусочек HTML, идущий до самого приложения
  response.write(preAppHTML)

  // По мере того, как рендерятся новые кусочки...
  stream.on('data', function (chunk) {
    // Пишем их в ответ сервера
    response.write(chunk)
  })

  // Когда рендеринг приложения завершён
  stream.on('end', function () {
    // Дописываем остаток HTML-шаблона и завершаем запись в поток
    response.end(postAppHTML)
  })

  // Если при рендеринге произошла ошибка...
  stream.on('error', function (error) {
    // Логируем её в консоль
    console.error(error)
    // И говорим клиенту, что что-то пошло не так
    return response
      .status(500)
      .send('Server Error')
  })
})
```

Как вы видите, по сравнению с предыдущей версией особо ничего не усложнилось, даже если вы раньше не сталкивались с потоками. Мы просто:

1. Создаём поток
2. Записываем в поток "открывающий" HTML
3. По мере готовности записываем в поток части отрендеренного приложения
4. Записываем в поток "закрывающий" HTML и завершаем поток
5. Обрабатываем ошибки

## Кеширование компонентов

SSR во Vue работает быстро, но можно ещё больше улучшить быстродействие, кешируя результаты рендеринга компонентов. Впрочем, важно понимать, что это — продвинутый механизм, поскольку кеширование неправильных компонентов (или правильных компонентов с неправильными ключами) может привести к ошибкам рендеринга приложения. В частном случае:

<p class="tip">Не следует кешировать компоненты, содержащие потомков, чьё состояние зависит от глобального (напр. от состояния vuex store). Если вы это сделаете, дочерние компоненты (а по сути — всё под-дерево целиком) тоже закешируются. Будьте особенно аккуратны с компонентами, принимающими слоты и/или дочерние компоненты.</p>

### Настройка

Не забывая о вышесказанном, вот как работает кеширование компонентов.

Во-первых, в рендерер нужно передать [объект кеша](https://www.npmjs.com/package/vue-server-renderer#cache). Вот простой пример, использующий [lru-cache](https://github.com/isaacs/node-lru-cache):

``` js
var createRenderer = require('vue-server-renderer').createRenderer
var lru = require('lru-cache')

var renderer = createRenderer({
  cache: lru(1000)
})
```

В этом примере мы позволяем кешировать до 1000 уникальных рендеров. Для других конфигураций, более тонко оперирующих использованием оперативной памяти, см. [опции lru-cache](https://github.com/isaacs/node-lru-cache#options).

Далее, для компонентов, которые вы хотели бы кешировать, нужно указать:

- уникальное имя (`name`)
- функцию `serverCacheKey`, возвращающую уникальный ключ (в рамках компонента)

Например:

``` js
Vue.component({
  name: 'list-item',
  template: '<li>{{ item.name }}</li>',
  props: ['item'],
  serverCacheKey: function (props) {
    return props.item.type + '::' + props.item.id
  }
})
```

### Идеальные кешируемые компоненты

Любой "чистый" компонент можно безопасно кешировать. Чистыми считаются компоненты, гарантирующие рендеринг одинакового HTML для одних и тех же входных параметров. Типичными примерами являются:

- Статические компоненты (т.к. они всегда генерируют один и тот же HTML, так что функция `serverCacheKey` может всегда возвращать `true`)
- Компоненты элементов списков (для больших списков, кеширование элементов может значительно улучшить производительность)
- Общие компоненты UI (напр. кнопки, алерты и т.д. — по крайней мере те, что принимают контент через входные параметры, а не через слоты и/или дочерние элементы)

## Процесс сборки, роутинг и гидрация состояния Vuex

К этому моменту вы должны понимать основы рендеринга на сервере. Однако, при добавлении процесса сборки, роутинга и vuex в картине появятся новые детали.

Если вы хотите действительно хорошо разобраться в SSR сложных приложений, мы советуем ознакомиться со следующими ресурсами:

- [документация vue-server-renderer](https://www.npmjs.com/package/vue-server-renderer#api): более подробно о том, о чём мы уже здесь говорили, а также по более продвинутым темам, таким как [предотвращение cross-request-загрязнения](https://www.npmjs.com/package/vue-server-renderer#why-use-bundlerenderer) и [и добавление отдельной серверной сборки](https://www.npmjs.com/package/vue-server-renderer#creating-the-server-bundle)
- [vue-hackernews-2.0](https://github.com/vuejs/vue-hackernews-2.0): подробный пример, объединяющий все основные библиотеки и концепции Vue в единое приложение
