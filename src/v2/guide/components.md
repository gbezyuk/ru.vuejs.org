---
title: Компоненты
type: guide
order: 11
---

## Что такое компоненты?

Компоненты&nbsp;&mdash; это одна из&nbsp;самых мощных возможностей Vue. Компоненты расширяют базовые HTML-элементы, позволяя инкапсулировать повторно используемый код. Не&nbsp;вдаваясь в&nbsp;подробности, можно сказать, что компоненты&nbsp;&mdash; это пользовательские элементы, к&nbsp;которым компилятор Vue привязывает определённое поведение. В&nbsp;некоторых случаях компоненты также можно задать с&nbsp;помощью нативных элементов, расширенных специальным атрибутом `is`.

## Использование компонентов

### Регистрация

В&nbsp;предыдущих разделах мы&nbsp;научились создавать инстансы Vue:

``` js
new Vue({
  el: '#some-element',
  // опции
})
```

Зарегистрировать глобальный компонент можно с&nbsp;помощью `Vue.component(tagName, options)`:

``` js
Vue.component('my-component', {
  // опции
})
```

<p class="tip">Обратите внимание, что Vue не&nbsp;требует соблюдения [правил W3C](http://www.w3.org/TR/custom-elements/#concepts) для пользовательских имён тегов (таких как требования использования только нижнего регистра и&nbsp;применения дефисов), хотя следование этим соглашениям считается хорошей практикой.</p>

Зарегистрированный компонент можно использовать в&nbsp;шаблоне инстанса как пользовательский элемент `<my-component></my-component>`. Компонент обязательно должен быть зарегистрирован **до&nbsp;создания корневого инстанса Vue**. Вот полный пример:

``` html
<div id="example">
  <my-component></my-component>
</div>
```

``` js
// регистрация
Vue.component('my-component', {
  template: '<div>Пользовательский компонент!</div>'
})

// создание корневого инстанса
new Vue({
  el: '#example'
})
```

Результатом рендеринга будет:

``` html
<div id="example">
  <div>Пользовательский компонент!</div>
</div>
```

{% raw %}
<div id="example" class="demo">
  <my-component></my-component>
</div>
<script>
Vue.component('my-component', {
  template: '<div>Пользовательский компонент!</div>'
})
new Vue({ el: '#example' })
</script>
{% endraw %}

### Локальные компоненты

Необязательно регистрировать все компоненты глобально. Можно сделать компонент доступным только в&nbsp;области видимости другого инстанса или компонента, зарегистрировав его опцией `components`:

``` js
var Child = {
  template: '<div>Пользовательский компонент!</div>'
}

new Vue({
  // ...
  components: {
    // <my-component> будет доступен только в шаблоне родителя
    'my-component': Child
  }
})
```

Аналогичные принципы инкапсуляции применимы и&nbsp;для всех остальных регистрируемых пользовательских расширений Vue, например для директив.

### Особенности парсинга DOM-шаблона

Если в&nbsp;качестве шаблона используется DOM (то&nbsp;есть в&nbsp;опции `el` указана точка монтирования, уже содержащая контент), это накладывает определённые ограничения, обусловленные самим языком HTML. Тогда содержимое шаблона поступает в&nbsp;Vue только **после** того, как браузер распарсит и&nbsp;нормализует HTML-страницу. При этом определённые сочетания элементов могут не&nbsp;соответствовать нормам языка HTML. Например, есть ограничение какие элементы могут находиться внутри элементов `<ul>`, `<ol>`, `<table>` и&nbsp;`<select>`. Для некоторых других элементов, например для `<option>`, подобным&nbsp;же образом ограничен список допустимых родительских элементов.

С&nbsp;такими элементами пользовательские компоненты могут работать некорректно. Рассмотрим пример:

``` html
<table>
  <my-row>...</my-row>
</table>
```

Пользовательский компонент `<my-row>` будет отброшен браузером как некорректный, что в&nbsp;конечном итоге приведёт к&nbsp;ошибке во&nbsp;время рендеринга. Обойти эту проблему можно используя специальный атрибут `is`:

``` html
<table>
  <tr is="my-row"></tr>
</table>
```

**Стоит заметить, что эти ограничения не&nbsp;действуют, если шаблоны получены из&nbsp;следующих источников**:

- `<script type="text/x-template">`
- inline-строки JavaScript
- `.vue`-компоненты

Поэтому мы&nbsp;советуем, по&nbsp;возможности, всегда использовать строковые шаблоны.

### Опция `data` должна быть функцией

Большую часть опций, которые можно передавать в&nbsp;конструктор Vue, допускается использовать и&nbsp;в&nbsp;компонентах. Есть одно важное исключение: опция `data` должна быть функцией. Попытаемся выполнить следующий код:

``` js
Vue.component('my-component', {
  template: '<span>{{ message }}</span>',
  data: {
    message: 'привет!'
  }
})
```

Vue остановится и&nbsp;выведет в&nbsp;консоль предупреждение, что опция `data` в&nbsp;компонентах должна быть функцией. Тем не&nbsp;менее, неплохо&nbsp;бы понимать, почему существуют такие правила&nbsp;&mdash; так что давайте немного схитрим:

``` html
<div id="example-2">
  <simple-counter></simple-counter>
  <simple-counter></simple-counter>
  <simple-counter></simple-counter>
</div>
```

``` js
var data = { counter: 0 }

Vue.component('simple-counter', {
  template: '<button v-on:click="counter += 1">{{ counter }}</button>',
  // технически data является функцией, так что Vue
  // не будет жаловаться, но при каждом вызове эта функция
  // возвращает ссылку на один и тот же внешний объект
  data: function () {
    return data
  }
})

new Vue({
  el: '#example-2'
})
```

{% raw %}
<div id="example-2" class="demo">
  <simple-counter></simple-counter>
  <simple-counter></simple-counter>
  <simple-counter></simple-counter>
</div>
<script>
var data = { counter: 0 }
Vue.component('simple-counter', {
  template: '<button v-on:click="counter += 1">{{ counter }}</button>',
  data: function () {
    return data
  }
})
new Vue({
  el: '#example-2'
})
</script>
{% endraw %}

Какая неожиданность! Увеличение одного из&nbsp;счётчиков также увеличит и&nbsp;остальные два, поскольку все они используют один и&nbsp;тот&nbsp;же объект `data`. Исправим ошибку: пусть функция при каждом вызове возвращает вновь созданный объект `data`.

``` js
data: function () {
  return {
    counter: 0
  }
}
```

Теперь у&nbsp;каждого счётчика есть свое собственное внутреннее состояние:

{% raw %}
<div id="example-2-5" class="demo">
  <my-component></my-component>
  <my-component></my-component>
  <my-component></my-component>
</div>
<script>
Vue.component('my-component', {
  template: '<button v-on:click="counter += 1">{{ counter }}</button>',
  data: function () {
    return {
      counter: 0
    }
  }
})
new Vue({
  el: '#example-2-5'
})
</script>
{% endraw %}

### Композиция компонентов

Компоненты обычно используются совместно, в&nbsp;основном в&nbsp;рамках иерархических отношений, когда компонент-родитель A&nbsp;ссылается на&nbsp;компонент-потомок B&nbsp;в&nbsp;своём собственном шаблоне. Для этого нужно обеспечить коммуникацию компонентов друг с&nbsp;другом. Например, родитель может передавать данные потомку, а&nbsp;потомок, в&nbsp;свою очередь, может уведомлять родителя о&nbsp;произошедших событиях. С&nbsp;помощью чётко заданного интерфейса взаимодействие между компонентами сводится к&nbsp;необходимому минимуму. Благодаря такому подходу можно писать и&nbsp;анализировать код каждого компонента в&nbsp;условиях относительной изоляции. Это упрощает поддержку и&nbsp;потенциально облегчает повторное использование компонентов.

Во&nbsp;Vue.js иерархические отношения подчиняются следующему принципу: **&laquo;входные параметры&nbsp;&mdash; вниз, события&nbsp;&mdash; вверх&raquo; (&laquo;props down, events&nbsp;up&raquo;)**. Родитель передаёт данные потомку через **входные параметры (props)**, а&nbsp;потомок посылает сообщения родителю посредством **событий (events)**. Давайте посмотрим как это работает.

<p style="text-align: center">
  <img style="width:300px" src="/images/props-events.png" alt="props down, events up">
</p>

## Входные параметры

### Передача данных через входные параметры

Каждый инстанс компонента имеет свою собственную **изолированную область видимости**. Поэтому напрямую обращаться к&nbsp;данным родительского компонента из&nbsp;шаблона компонента-потомка невозможно (да&nbsp;это и&nbsp;не&nbsp;требуется). Вместо этого данные передаются вниз по&nbsp;цепочке иерархии с&nbsp;помощью **входных параметров**.

Входной параметр&nbsp;&mdash; это пользовательский атрибут для передачи информации из&nbsp;родительского компонента. Ожидаемые входные параметры нужно явно определить в&nbsp;потомке с&nbsp;помощью [опции `props`](../api/#props):

``` js
Vue.component('child', {
  // определяем входной параметр
  props: ['message'],
  // как и другие данные, входной параметр можно использовать
  // внутри шаблонов (а также и в методах, обращаясь через this.message)
  template: '<span>{{ message }}</span>'
})
```

Мы&nbsp;можем передать в&nbsp;компонент строку, например так:

``` html
<child message="привет!"></child>
```

Результатом будет:

{% raw %}
<div id="prop-example-1" class="demo">
  <child message="привет!"></child>
</div>
<script>
new Vue({
  el: '#prop-example-1',
  components: {
    child: {
      props: ['message'],
      template: '<span>{{ message }}</span>'
    }
  }
})
</script>
{% endraw %}

### camelCase против kebab-case

Атрибуты HTML являются регистронезависимыми, так что **при использовании в&nbsp;DOM в&nbsp;качестве шаблона** вместо camelCase-версий имён входных параметров приходится применять их&nbsp;kebab-case эквиваленты (разделять слова дефисом):

``` js
Vue.component('child', {
  // camelCase в JavaScript
  props: ['myMessage'],
  template: '<span>{{ myMessage }}</span>'
})
```

``` html
<!-- kebab-case в HTML -->
<child my-message="привет!"></child>
```

Впрочем, строковые шаблоны не&nbsp;накладывают и&nbsp;этого ограничения.

### Динамические входные параметры

С&nbsp;помощью директивы `v-bind` входные параметры можно динамически связывать с&nbsp;данными родительского компонента аналогично тому, как обычные атрибуты связываются с&nbsp;выражениями. Любое обновление данных в&nbsp;родителе в&nbsp;этом случае будет передано и&nbsp;в&nbsp;компонент-потомок:

``` html
<div>
  <input v-model="parentMsg">
  <br>
  <child v-bind:my-message="parentMsg"></child>
</div>
```

Зачастую проще использовать для `v-bind` сокращённую запись:

``` html
<child :my-message="parentMsg"></child>
```

Результат:

{% raw %}
<div id="demo-2" class="demo">
  <input v-model="parentMsg">
  <br>
  <child v-bind:my-message="parentMsg"></child>
</div>
<script>
new Vue({
  el: '#demo-2',
  data: {
    parentMsg: 'Сообщение из родителя'
  },
  components: {
    child: {
      props: ['myMessage'],
      template: '<span>{{myMessage}}</span>'
    }
  }
})
</script>
{% endraw %}

### Различие между литералами и динамическими параметрами

Часто встречается ошибка, когда число передаётся компоненту напрямую в&nbsp;виде константы:

``` html
<!-- при такой записи в компонент будет передана строка "1" -->
<comp some-prop="1"></comp>
```

Так как в&nbsp;качестве параметра передан литерал, компонент получит не&nbsp;число, а&nbsp;строку `"1"`. Для передачи числа нужно использовать директиву `v-bind`, поскольку её&nbsp;значение вычисляется как выражение JavaScript:

``` html
<!-- этот синтаксис позволит передать в компонент число -->
<comp v-bind:some-prop="1"></comp>
```

### Однонаправленный поток данных

Входные параметры обеспечивают **однонаправленный** поток данных от&nbsp;родительского компонента к&nbsp;потомкам. Если свойство компонента-родителя изменилось, это изменение передаётся потомку, но&nbsp;не&nbsp;наоборот. Если&nbsp;бы потомки могли произвольно изменять состояние родителя, понять структуру потоков данных внутри приложения было&nbsp;бы намного труднее. Благодаря однонаправленным потокам такая ситуация исключается.

Кроме того, при любом обновлении родительского компонента каждый входной параметр потомка обновляется до&nbsp;актуального значения. Поэтому **не&nbsp;следует изменять значения** входных параметров внутри компонента и&nbsp;расчитывать на&nbsp;их&nbsp;сохранность. При попытке изменить входной параметр Vue выведет предупреждение в&nbsp;консоли.

Новички обычно пытаются изменить значение входного параметра в&nbsp;двух случаях:

1. Если параметр нужен лишь для передачи потомку начального значения, после чего планируется использовать эту переменную как локальную.

2. Если значению, которое передаётся как параметр, требуется дальнейшая обработка.

Правильное решение этих задач следующее:

1. Объявить локальную переменную, которая принимает значение входного параметра при инициализации:

  ``` js
  props: ['initialCounter'],
  data: function () {
    return { counter: this.initialCounter }
  }
  ```

2. Определить вычисляемое свойство, основанное на&nbsp;значении входного параметра:

  ``` js
  props: ['size'],
  computed: {
    normalizedSize: function () {
      return this.size.trim().toLowerCase()
    }
  }
  ```

<p class="tip">Обратите внимание, что объекты и&nbsp;массивы в&nbsp;JavaScript передаются по&nbsp;ссылке, так что если входным параметром является объект или массив, его изменение внутри потомка **повлияет** на&nbsp;состояние родительского компонента.</p>

### Валидация входных параметров

В&nbsp;компонентах можно не&nbsp;только указать список ожидаемых параметров, но&nbsp;и&nbsp;предъявить к&nbsp;этим параметрам определённые требования. Если полученные параметры не&nbsp;удовлетворяют требованиям, Vue выведет предупреждение. Эта возможность особенно полезна при создании компонентов для внешнего использования.

Вместо задания списка параметров с&nbsp;помощью массива строк, можно использовать объект с&nbsp;правилами валидации:

``` js
Vue.component('example', {
  props: {
    // простая проверка типа (`null` означает допустимость любого типа)
    propA: Number,
    // несколько допустимых типов
    propB: [String, Number],
    // обязательное значение строкового типа
    propC: {
      type: String,
      required: true
    },
    // число со значением по умолчанию
    propD: {
      type: Number,
      default: 100
    },
    // значения по умолчанию для объектов и массивов
    // должны задаваться через функцию
    propE: {
      type: Object,
      default: function () {
        return { message: 'привет!' }
      }
    },
    // пользовательская функция для валидации
    propF: {
      validator: function (value) {
        return value > 10
      }
    }
  }
})
```

В&nbsp;качестве параметра `type` используется один из&nbsp;нижеперечисленных нативных конструкторов:

- String
- Number
- Boolean
- Function
- Object
- Array

Кроме того, `type` может быть и&nbsp;пользовательской функцией-конструктором. При этом проверка соответствия выполняется с&nbsp;помощью `instanceof`.

На&nbsp;ошибки валидации Vue реагирует, выводя предупреждения в&nbsp;консоль (при использовании development-сборки).

## Пользовательские события

Мы&nbsp;узнали, что компонент-родитель может передавать данные потомкам через входные параметры. Но&nbsp;как организовать связь в&nbsp;обратном направлении? Самое время поговорить о&nbsp;системе пользовательских событий Vue.

### Использование `v-on` с пользовательскими событиями

Каждый инстанс Vue поддерживает [интерфейс событий](../api/#Методы-инстанса-—-события), позволяющий:

- Отслеживать события, используя `$on(eventName)`
- Порождать события, используя `$emit(eventName)`

<p class="tip">Обратите внимание, что система событий Vue отделена от&nbsp;[EventTarget API](https://developer.mozilla.org/en-US/docs/Web/API/EventTarget) браузера. Хотя они и&nbsp;похожи, `$on` и&nbsp;`$emit` &mdash; это не&nbsp;псевдонимы `addEventListener` и&nbsp;`dispatchEvent`.</p>

Кроме того, родительский компонент может зарегистрировать подписчика событий, используя директиву `v-on` непосредственно в&nbsp;шаблоне при создании компонента-потомка.

<p class="tip">Вы&nbsp;не&nbsp;можете использовать `$on` для прослушивания событий, генерируемых в&nbsp;потомках. Вы&nbsp;должны использовать `v-on` непосредственно в&nbsp;шаблоне, как в&nbsp;приведённом ниже примере.</p>

Вот пример:

``` html
<div id="counter-event-example">
  <p>{{ total }}</p>
  <button-counter v-on:increment="incrementTotal"></button-counter>
  <button-counter v-on:increment="incrementTotal"></button-counter>
</div>
```

``` js
Vue.component('button-counter', {
  template: '<button v-on:click="increment">{{ counter }}</button>',
  data: function () {
    return {
      counter: 0
    }
  },
  methods: {
    increment: function () {
      this.counter += 1
      this.$emit('increment')
    }
  },
})

new Vue({
  el: '#counter-event-example',
  data: {
    total: 0
  },
  methods: {
    incrementTotal: function () {
      this.total += 1
    }
  }
})
```

{% raw %}
<div id="counter-event-example" class="demo">
  <p>{{ total }}</p>
  <button-counter v-on:increment="incrementTotal"></button-counter>
  <button-counter v-on:increment="incrementTotal"></button-counter>
</div>
<script>
Vue.component('button-counter', {
  template: '<button v-on:click="increment">{{ counter }}</button>',
  data: function () {
    return {
      counter: 0
    }
  },
  methods: {
    increment: function () {
      this.counter += 1
      this.$emit('increment')
    }
  },
})
new Vue({
  el: '#counter-event-example',
  data: {
    total: 0
  },
  methods: {
    incrementTotal: function () {
      this.total += 1
    }
  }
})
</script>
{% endraw %}

Важно отметить, что потомок остаётся полностью независимым от&nbsp;всего происходящего снаружи. Он&nbsp;всего лишь уведомляет внешний мир о&nbsp;происходящем с&nbsp;ним, на&nbsp;случай если родительскому компоненту это будет интересно.

#### Подписка на нативные события в компонентах

Иногда нужно подписаться на&nbsp;нативные события браузера в&nbsp;корневом элементе компонента. В&nbsp;таких случаях можно применить `v-on` с&nbsp;модификатором `.native`, например так:

``` html
<my-component v-on:click.native="doTheThing"></my-component>
```

### Поля ввода форм с использованием пользовательских событий

С&nbsp;помощью пользовательских событий можно также создавать пользовательские поля ввода с&nbsp;поддержкой директивы `v-model`. Вспомните, что

``` html
<input v-model="something">
```

это всего лишь синтаксический сахар для:

``` html
<input v-bind:value="something" v-on:input="something = $event.target.value">
```

При использовании с&nbsp;компонентом, запись упрощается&nbsp;до:

``` html
<custom-input v-bind:value="something" v-on:input="something = arguments[0]"></custom-input>
```

Таким образом, чтобы иметь возможность работать с&nbsp;`v-model`, компонент должен:

- принимать входной параметр `value`
- порождать событие `input` с&nbsp;новым значением

Давайте разберём в&nbsp;качестве примера простое поле ввода денежной суммы с&nbsp;точкой в&nbsp;качестве десятичного разделителя:

``` html
<currency-input v-model="price"></currency-input>
```

``` js
Vue.component('currency-input', {
  template: '\
    <span>\
      $\
      <input\
        ref="input"\
        v-bind:value="value"\
        v-on:input="updateValue($event.target.value)"\
      >\
    </span>\
  ',
  props: ['value'],
  methods: {
    // Вместо того, чтобы обновлять значение напрямую,
    // в этом методе мы выполняем нормализацию и форматирование
    // введённого значения, а затем порождаем событие,
    // уведомляющее родительский компонент об изменениях
    updateValue: function (value) {
      var formattedValue = value
        // Удалить пробелы с обеих сторон
        .trim()
        // Сократить до 2 знаков после запятой
        .slice(0, value.indexOf('.') + 3)
      // Если значение не нормализовано — нормализуем вручную
      if (formattedValue !== value) {
        this.$refs.input.value = formattedValue
      }
      // Порождаем событие с обновлённым значением поля ввода
      this.$emit('input', Number(formattedValue))
    }
  }
})
```

{% raw %}
<div id="currency-input-example" class="demo">
  <currency-input v-model="price"></currency-input>
</div>
<script>
Vue.component('currency-input', {
  template: '\
    <span>\
      $\
      <input\
        ref="input"\
        v-bind:value="value"\
        v-on:input="updateValue($event.target.value)"\
      >\
    </span>\
  ',
  props: ['value'],
  methods: {
    updateValue: function (value) {
      var formattedValue = value
        .trim()
        .slice(0, value.indexOf('.') + 3)
      if (formattedValue !== value) {
        this.$refs.input.value = formattedValue
      }
      this.$emit('input', Number(formattedValue))
    }
  }
})
new Vue({
  el: '#currency-input-example',
  data: { price: '' }
})
</script>
{% endraw %}

Очевидно, что наша реализация не&nbsp;лишена недостатков. Например, пользователь может ввести несколько десятичных точек, а&nbsp;кое-где и&nbsp;буквы вместо цифр. Для тех, кого интересует пример менее тривиальной и&nbsp;более надёжной реализации, вот&nbsp;он:

<iframe width="100%" height="300" src="https://jsfiddle.net/chrisvfritz/1oqjojjx/embedded/result,html,js" allowfullscreen="allowfullscreen" frameborder="0"></iframe>

Интерфейс событий может быть использован не&nbsp;только для связи с&nbsp;полями ввода форм внутри компонентов, но&nbsp;и&nbsp;для создания более необычных полей ввода. К&nbsp;примеру, представьте себе следующие возможности:

``` html
<voice-recognizer v-model="question"></voice-recognizer>
<webcam-gesture-reader v-model="gesture"></webcam-gesture-reader>
<webcam-retinal-scanner v-model="retinalImage"></webcam-retinal-scanner>
```

### Коммуникация между компонентами, не связанными иерархически

Иногда нужно обеспечить обмен информацией между компонентами, которые не&nbsp;состоят в&nbsp;отношениях родитель-потомок. В&nbsp;простых случаях можно использовать пустой инстанс Vue в&nbsp;качестве централизованной шины событий:

``` js
var bus = new Vue()
```
``` js
// в методе компонента A
bus.$emit('id-selected', 1)
```
``` js
// в обработчике created компонента B
bus.$on('id-selected', function (id) {
  // ...
})
```

Для более сложных случаев подойдет специализированный [паттерн управления состоянием](state-management.html).

## Распределение контента слотами

Нередко хочется вкладывать компоненты друг в&nbsp;друга следующим образом:

``` html
<app>
  <app-header></app-header>
  <app-footer></app-footer>
</app>
```

Здесь стоит обратить внимание на&nbsp;две вещи:

1. Компонент `<app>` не&nbsp;знает, какой контент он&nbsp;будет содержать после монтирования. Это определяется родительским компонентом, использующим `<app>`.

2. Скорее всего, у&nbsp;компонента `<app>` есть собственный шаблон.

Чтобы такая композиция работала, необходим метод &laquo;переплетения&raquo; шаблона компонента и&nbsp;внутреннего содержимого, указанного при его использовании в&nbsp;родительском контексте. Этот процесс называется **распределением контента**, или, в&nbsp;терминах Angular, &laquo;включением&raquo; (&laquo;transclusion&raquo;). Во&nbsp;Vue.js реализован API распределения контента, примерно соответствующий текущему [черновику спецификации Web&nbsp;Components](https://github.com/w3c/webcomponents/blob/gh-pages/proposals/Slots-Proposal.md). В&nbsp;нём используется специальный элемент `<slot>`, служащий &laquo;точкой выхода&raquo; для исходного контента.

### Область видимости при компиляции

Перед тем как углубиться в&nbsp;рассмотрение API слотов, давайте сперва разберёмся, в&nbsp;какой области видимости компилируется содержимое шаблонов. Представим такой шаблон:

``` html
<child-component>
  {{ message }}
</child-component>
```

Из&nbsp;какого контекста берется переменная `message`, контекста родителя или контекста потомка? Правильный ответ&nbsp;&mdash; из&nbsp;контекста родителя. Действует простое правило:

> Всё в&nbsp;шаблоне родительского компонента компилируется в&nbsp;области видимости родителя; всё в&nbsp;шаблоне потомка&nbsp;&mdash; в&nbsp;области видимости потомка.

Часто встречается ошибка, когда в&nbsp;шаблоне родителя указывается связывание со&nbsp;свойством компонента-потомка:

``` html
<!-- НЕ сработает -->
<child-component v-show="someChildProperty"></child-component>
```

Если `someChildProperty` является свойством потомка, вышеприведённый пример работать не&nbsp;будет. Шаблон родителя не&nbsp;имеет никакого представления о&nbsp;состоянии компонента-потомка.

Если все-таки нужно привязать директивы из&nbsp;области видимости компонента-потомка к&nbsp;корневому элементу, это необходимо сделать в&nbsp;его&nbsp;же шаблоне:

``` js
Vue.component('child-component', {
  // такой вариант сработает, поскольку мы находимся
  // в правильной области видимости
  template: '<div v-show="someChildProperty">Child</div>',
  data: function () {
    return {
      someChildProperty: true
    }
  }
})
```

Контент, полученный через систему распределения, также будет компилироваться в&nbsp;родительской области видимости.

### Вариант с единственным слотом

Родительский контент будет **отброшен**, если в&nbsp;шаблоне компонента-потомка компонента нет хотя&nbsp;бы одного элемента `<slot>`. В&nbsp;случае, если слот всего один и&nbsp;не&nbsp;содержит атрибутов, всё содержимое родительского элемента будет помещено в&nbsp;DOM на&nbsp;место слота, замещая его собой.

Изначальное содержимое тега `<slot>` считается **резервным контентом**. Оно компилируется в&nbsp;области видимости компонента-потомка и&nbsp;отображается только в&nbsp;том случае, если родительский элемент пуст и&nbsp;не&nbsp;содержит никакого контента для передачи потомку.

Предположим, у&nbsp;нас есть компонент `my-component`, с&nbsp;таким шаблоном:

``` html
<div>
  <h2>Заголовок компонента-потомка</h2>
  <slot>
    Этот текст будет отображён только если
    не будет передано контента для дистрибьюции.
  </slot>
</div>
```

И&nbsp;родитель, использующий этот компонент:

``` html
<div>
  <h1>Заголовок компонента-родителя</h1>
  <my-component>
    <p>Немного оригинального контента</p>
    <p>И ещё немного</p>
  </my-component>
</div>
```

Результатом рендеринга будет:

``` html
<div>
  <h1>Заголовок компонента-родителя</h1>
  <div>
    <h2>Заголовок компонента-потомка</h2>
    <p>Немного оригинального контента</p>
    <p>И ещё немного</p>
  </div>
</div>
```

### Именованные слоты

Для элементов `<slot>` можно указать специальный атрибут `name`, который используется для ещё более гибкой дистрибьюции контента. Можно создать несколько слотов с&nbsp;различными именами. Именованный слот получит весь контент, находящийся в&nbsp;элементе с&nbsp;соответствующим значением атрибута `slot`.

Если одному из&nbsp;слотов не&nbsp;задать имя, он&nbsp;станет **слотом по&nbsp;умолчанию**, в&nbsp;который попадёт весь контент, для которого имя слота не&nbsp;указано. В&nbsp;случае отсутствия безымянного слота, такой контент будет попросту отброшен.

Для примера, предположим что у&nbsp;нас есть компонент `app-layout` с&nbsp;таким шаблоном:

``` html
<div class="container">
  <header>
    <slot name="header"></slot>
  </header>
  <main>
    <slot></slot>
  </main>
  <footer>
    <slot name="footer"></slot>
  </footer>
</div>
```

Шаблон родителя:

``` html
<app-layout>
  <h1 slot="header">Здесь мог бы быть заголовок страницы</h1>

  <p>Абзац основного контента.</p>
  <p>И ещё один.</p>

  <p slot="footer">Вот контактная информация</p>
</app-layout>
```

Результатом рендеринга будет:

``` html
<div class="container">
  <header>
    <h1>Здесь мог бы быть заголовок страницы</h1>
  </header>
  <main>
    <p>Абзац основного контента.</p>
    <p>И ещё один.</p>
  </main>
  <footer>
    <p>Вот контактная информация</p>
  </footer>
</div>
```

API распределения контента&nbsp;&mdash; это очень полезный механизм для создания компонентов, которые будут использоваться совместно.

### Слоты с ограниченной областью видимости

> Добавлено в&nbsp;версии 2.1.0

Слот с&nbsp;ограниченной областью видимости&nbsp;&mdash; это особый тип слота, который применяется как повторно используемый шаблон, то&nbsp;есть в&nbsp;этот слот передаются данные, а&nbsp;не&nbsp;уже отрендеренные элементы.

В&nbsp;компоненте-потомке нужно просто передать данные в&nbsp;слот, так&nbsp;же, как входные параметры передаются в&nbsp;компонент:

``` html
<div class="child">
  <slot text="сообщение от потомка"></slot>
</div>
```

В&nbsp;родителе, элемент `<template>` с&nbsp;особым атрибутом `scope` указывает, что это шаблон для слота с&nbsp;ограниченной областью видимости. Значение `scope` &mdash; это имя временной переменной, содержащей входные параметры, переданные от&nbsp;потомка:

``` html
<div class="parent">
  <child>
    <template scope="props">
      <span>сообщение от родителя</span>
      <span>{{ props.text }}</span>
    </template>
  </child>
</div>
```

Результатом рендеринга кода выше будет:

``` html
<div class="parent">
  <div class="child">
    <span>сообщение от родителя</span>
    <span>сообщение от потомка</span>
  </div>
</div>
```

Более характерное применение для слотов с&nbsp;ограниченной областью видимости&nbsp;&mdash; это компонент, выводящий список элементов, в&nbsp;котором пользователь может переопределить вид элемента:

``` html
<my-awesome-list :items="items">
  <!-- слот с ограниченной областью видимости может быть и именованным -->
  <template slot="item" scope="props">
    <li class="my-fancy-item">{{ props.text }}</li>
  </template>
</my-awesome-list>
```

И&nbsp;шаблон самого компонента списка:

``` html
<ul>
  <slot name="item"
    v-for="item in items"
    :text="item.text">
    <!-- здесь — контент для резервного отображения -->
  </slot>
</ul>
```

## Динамическое переключение компонентов

Можно подключить несколько компонентов к&nbsp;одной и&nbsp;той&nbsp;же точке монтирования, а&nbsp;затем динамически переключаться между ними. Для этого используется псевдоэлемент `<component>` и&nbsp;динамическое связывание его атрибута `is`:

``` js
var vm = new Vue({
  el: '#example',
  data: {
    currentView: 'home'
  },
  components: {
    home: { /* ... */ },
    posts: { /* ... */ },
    archive: { /* ... */ }
  }
})
```

``` html
<component v-bind:is="currentView">
  <!-- изменяя vm.currentView можно переключаться между компонентами -->
</component>
```

При желании можно связываться с&nbsp;объектами компонентов и&nbsp;напрямую:

``` js
var Home = {
  template: '<p>Добро пожаловать домой!</p>'
}

var vm = new Vue({
  el: '#example',
  data: {
    currentView: Home
  }
})
```

### `keep-alive`

Иногда бывает выгодно хранить отключенные компоненты в&nbsp;памяти, чтобы не&nbsp;терять их&nbsp;состояния и&nbsp;не&nbsp;выполнять их&nbsp;повторный рендеринг. Для этого нужно обернуть динамический компонент в&nbsp;псевдоэлемент `<keep-alive>`:

``` html
<keep-alive>
  <component :is="currentView">
    <!-- неактивные компоненты будут закешированы! -->
  </component>
</keep-alive>
```

Более детально `<keep-alive>` рассмотрен в&nbsp;[справочнике по API](../api/#keep-alive).

## Разное

### Создание компонентов для повторного использования

Создавая компоненты, неплохо понимать, планируется&nbsp;ли использовать их&nbsp;где-то ещё в&nbsp;будущем. Если компоненты одноразовые, они могут быть и&nbsp;сильно связанными. В&nbsp;компонентах, предназначенных для повторного использования, следует определить чёткий публичный интерфейс, в&nbsp;котором нет излишних предположений о&nbsp;контексте использования компонента.

API компонентов Vue состоит из&nbsp;трёх частей: входных параметров, событий и&nbsp;слотов:

- **Входные параметры** позволяют передавать в&nbsp;компонент данные извне.

- **События** позволяют компонентам воздействовать на&nbsp;внешнее окружение.

- **Слоты** позволяют внешнему окружению дополнять компоненты новым контентом.

Благодаря специальному сокращённому синтаксису `v-bind` и&nbsp;`v-on`, назначение компонента можно коротко и&nbsp;ясно выразить в&nbsp;шаблоне:

``` html
<my-component
  :foo="baz"
  :bar="qux"
  @event-a="doThis"
  @event-b="doThat"
>
  <img slot="icon" src="...">
  <p slot="main-text">Привет!</p>
</my-component>
```

### Ссылки на компоненты-потомки

Несмотря на&nbsp;существование таких средств как входные параметры и&nbsp;события, иногда всё&nbsp;же возникает необходимость обратиться к&nbsp;компонентам-потомкам в&nbsp;JavaScript напрямую. Для этих целей можно при помощи атрибута `ref` назначить компоненту идентификатор. Например:

``` html
<div id="parent">
  <user-profile ref="profile"></user-profile>
</div>
```

``` js
var parent = new Vue({ el: '#parent' })
// получаем инстанс компонента-потомка
var child = parent.$refs.profile
```

Если `ref` используется вместе с&nbsp;директивой `v-for`, будет возвращен массив или объект со&nbsp;ссылками на&nbsp;инстансы, структурно повторяющий исходные данные.

<p class="tip">Объект `$refs` заполняется только после рендеринга компонента и&nbsp;не&nbsp;является реактивным. Считайте, что это крайнее средство для непосредственного вмешательства в&nbsp;работу компонента-потомка, и&nbsp;не&nbsp;используйте `$refs` в&nbsp;шаблонах и&nbsp;вычисляемых свойствах.</p>

### Асинхронные компоненты

Иногда бывает удобно разделить крупное приложение на&nbsp;части и&nbsp;подгружать компоненты с&nbsp;сервера только тогда, когда в&nbsp;них возникнет потребность. Для этого Vue позволяет определить компонент как функцию-фабрику, асинхронно возвращающую определение компонента. Vue вызовет фабричную функцию только тогда, когда компонент действительно понадобится, и&nbsp;закеширует результат для дальнейшего использования. Например:

``` js
Vue.component('async-example', function (resolve, reject) {
  setTimeout(function () {
    // Передаем шаблон компонента в коллбэк resolve
    resolve({
      template: '<div>Я — асинхронный!</div>'
    })
  }, 1000)
})
```

Функция-фабрика принимает параметр `resolve` &mdash; коллбэк, который вызывается после того, как определение компонента получено от&nbsp;сервера. Кроме того, можно вызвать `reject(reason)`, если загрузка по&nbsp;какой-либо причине не&nbsp;удалась. Мы&nbsp;используем `setTimeout` исключительно в&nbsp;демонстрационных целях; как именно получать компонент в&nbsp;реальной ситуации&nbsp;&mdash; решать только вам самим. Один из&nbsp;удачных подходов&nbsp;&mdash; это использовать асинхронные компоненты в&nbsp;связке с&nbsp;[функциями Webpack по&nbsp;разделению кода](http://webpack.github.io/docs/code-splitting.html):

``` js
Vue.component('async-webpack-example', function (resolve) {
  // специальный синтаксис require укажет Webpack
  // автоматически разделить сборку на части
  // для последующей асинхронной загрузки
  require(['./my-async-component'], resolve)
})
```

Вы&nbsp;также можете вернуть `Promise` в&nbsp;функции-фабрике, так что с&nbsp;Webpack&nbsp;2 и&nbsp;синтаксисом ES2015 можно сделать так:

``` js
Vue.component(
  'async-webpack-example',
  () => System.import('./my-async-component')
)
```

<p class="tip">Если вы&nbsp;используете <strong>Browserify</strong> и&nbsp;также хотите реализовать асинхронную загрузку компонентов, нам, к&nbsp;сожалению, придётся вас огорчить. Это невозможно, и&nbsp;вряд&nbsp;ли будет возможно когда-либо, так как сам создатель Browserify [прояснил](https://github.com/substack/node-browserify/issues/58#issuecomment-21978224), что асинхронная загрузка &laquo;не&nbsp;является функцией, которую Browserify когда-либо будет поддерживать&raquo;. По&nbsp;крайней мере, такова официальная позиция. Сообщество Browserify обнаружило возможные [обходные пути](https://github.com/vuejs/vuejs.org/issues/620), которые могут быть полезны в&nbsp;уже существующих сложных приложениях. Но&nbsp;в&nbsp;целом мы&nbsp;советуем использовать Webpack, обладающий полноценной встроенной поддержкой асинхронной загрузки частей сборки.</p>

### Соглашения по именованию компонентов

При регистрации компонентов (или входных параметров), можно использовать kebab-case, camelCase или TitleCase. Это не&nbsp;имеет никакого значения для Vue.

``` js
// при определении компонента
components: {
  // регистрация с использованием kebab-case
  'kebab-cased-component': { /* ... */ },
  // регистрация с использованием camelCase
  'camelCasedComponent': { /* ... */ },
  // регистрация с использованием TitleCase
  'TitleCasedComponent': { /* ... */ }
}
```

В&nbsp;HTML-шаблонах, однако, придётся использовать эквивалентный kebab-case:

``` html
<!-- всегда используйте kebab-case в HTML-шаблонах -->
<kebab-cased-component></kebab-cased-component>
<camel-cased-component></camel-cased-component>
<title-cased-component></title-cased-component>
```

При использовании **строковых** шаблонов ограничения регистронезависимости HTML не&nbsp;действуют. Это значит, что даже в&nbsp;шаблоне можно указывать компоненты и&nbsp;входные параметры как в&nbsp;camelCase, так и&nbsp;в&nbsp;TitleCase или kebab-case:

``` html
<!-- в строковых шаблонах вы вольны использовать любой подход! -->
<my-component></my-component>
<myComponent></myComponent>
<MyComponent></MyComponent>
```

Если компонент не&nbsp;содержит слотов, его можно даже сделать самозакрывающимся, указав `/` после имени:

``` html
<my-component/>
```

Ещё раз заметим, что это возможно **только при использовании строковых шаблонов**, поскольку самозакрывающие пользовательские элементы не&nbsp;соответствуют нормам языка HTML, и&nbsp;нативные парсеры браузеров такую запись не&nbsp;поймут.

### Рекурсивные компоненты

Компоненты могут рекурсивно вызывать самих себя в&nbsp;своих шаблонах. Однако, эта возможность доступна только при указании опции `name`:

``` js
name: 'unique-name-of-my-component'
```

Если компонент регистрируется глобально с&nbsp;помощью `Vue.component`, то&nbsp;опция `name` компонента автоматически становится равной его глобальному&nbsp;ID:

``` js
Vue.component('unique-name-of-my-component', {
  // ...
})
```

Если не&nbsp;соблюдать осторожность, рекурсивные компоненты могут привести к&nbsp;появлению бесконечных циклов:

``` js
name: 'stack-overflow',
template: '<div><stack-overflow></stack-overflow></div>'
```

Использование такого компонента приведёт к&nbsp;ошибке переполнения стека, поэтому следите, чтобы рекурсивный вызов был условным (т.е. чтобы в&nbsp;нём была директива `v-if`, которая рано или поздно станет ложной).

### Циклические ссылки между компонентами

Предположим, вы&nbsp;проектируете каталог файлов в&nbsp;виде дерева, похожего на&nbsp;Finder или Проводник. Представьте себе, что для этого используется компонент `tree-folder` с&nbsp;таким шаблоном:

``` html
<p>
  <span>{{ folder.name }}</span>
  <tree-folder-contents :children="folder.children"/>
</p>
```

Затем компонент `tree-folder-contents` с&nbsp;таким шаблоном:

``` html
<ul>
  <li v-for="child in children">
    <tree-folder v-if="child.children" :folder="child"/>
    <span v-else>{{ child.name }}</span>
  </li>
</ul>
```

Присмотритесь к&nbsp;примеру. Парадоксально, но&nbsp;каждый из&nbsp;этих компонентов **одновременно** является и&nbsp;потомком, и&nbsp;родителем другого компонента! При глобальной регистрации компонентов с&nbsp;использованием `Vue.component`, данный парадокс будет разрешен автоматически. Если это ваш случай, то&nbsp;можете дальше не&nbsp;читать.

С&nbsp;другой стороны, если компоненты импортируются с&nbsp;помощью **модульного сборщика**, такого как Webpack или Browserify, возникнет ошибка.

```
Failed to mount component: template or render function not defined.
```

Чтобы объяснить это явление, давайте назовем наши компоненты&nbsp;A и&nbsp;B.&nbsp;Модульный сборщик видит, что ему нужен компонент&nbsp;A, но&nbsp;A сперва нужен&nbsp;B, но&nbsp;B нужен&nbsp;A, и&nbsp;т.д. Сборщик застревает в&nbsp;цикле, не&nbsp;зная как полностью разрешить оба компонента. Чтобы это исправить, нам нужно указать сборщику точку в&nbsp;которой он&nbsp;сможет сказать: &laquo;Рано или поздно для разрешения&nbsp;A нужно разрешить&nbsp;B, но&nbsp;нет необходимости разрешать&nbsp;B прямо сейчас&raquo;.

Для нашего случая, мы&nbsp;сделаем такой точкой компонент `tree-folder`. Мы&nbsp;знаем, что компонент-потомок, порождающий парадокс&nbsp;&mdash; это `tree-folder-contents`. Поэтому мы&nbsp;не&nbsp;будем его регистрировать, пока не&nbsp;наступит событие жизненного цикла `beforeCreate`.

``` js
beforeCreate: function () {
  this.$options.components.TreeFolderContents = require('./tree-folder-contents.vue')
}
```

Проблема решена!

### Inline-шаблоны

Если у&nbsp;компонента-потомка присутствует специальный атрибут `inline-template`, содержимое элемента будет использовано не&nbsp;для распределения контента, а&nbsp;в&nbsp;качестве шаблона этого компонента. Это позволяет более гибко использовать шаблоны.

``` html
<my-component inline-template>
  <div>
    <p>Этот шаблон будет скомпилирован в области видимости компонента-потомка.</p>
    <p>Доступа к данным родителя нет.</p>
  </div>
</my-component>
```

С&nbsp;другой стороны, использование `inline-template` затрудняет понимание происходящего в&nbsp;шаблонах. Поэтому желательно задавать шаблоны внутри компонента с&nbsp;помощью опции `template` или в&nbsp;элементе `template` файла `.vue`.

### Определение шаблонов через X-Template

Еще один способ задания шаблонов&nbsp;&mdash; это специальные элементы `script` с&nbsp;типом `text/x-template` и&nbsp;идентификатором, на&nbsp;который можно сослаться при регистрации шаблона. Например:

``` html
<script type="text/x-template" id="hello-world-template">
  <p>Привет привет привет</p>
</script>
```

``` js
Vue.component('hello-world', {
  template: '#hello-world-template'
})
```

Эта возможность бывает полезной для демонстрационных приложений с&nbsp;большими шаблонами или для очень маленьких приложений. Тем не&nbsp;менее, в&nbsp;целом такого подхода следует избегать, так как шаблоны отделяются от&nbsp;остальных частей определения компонента.

### "Дешёвые" статические компоненты с использованием `v-once`

Рендеринг простых элементов HTML&nbsp;во Vue происходит достаточно быстро, но&nbsp;иногда встречаются компоненты в&nbsp;которых статических данных **очень** много. В&nbsp;таком случае можно указать в&nbsp;корневом элементе директиву `v-once`. С&nbsp;этой директивой компонент будет вычислен только в&nbsp;первый раз, а&nbsp;дальнейшая работа будет происходить с&nbsp;закешированной версией. Например:

``` js
Vue.component('terms-of-service', {
  template: '\
    <div v-once>\
      <h1>Условия Использования</h1>\
      ... много-много статического контента ...\
    </div>\
  '
})
```
