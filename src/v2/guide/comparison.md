---
title: Сравнение с другими фреймворками
type: guide
order: 29
---

Определённо, этот раздел руководства&nbsp;&mdash; самый трудный для написания, но&nbsp;он&nbsp;очень важен. Вероятно, вы&nbsp;уже решаете определённые задачи, используя тот или иной фреймворк или библиотеку, а&nbsp;сюда вас привело желание узнать, не&nbsp;позволит&nbsp;ли Vue упростить и&nbsp;улучшить вашу работу. На&nbsp;этот вопрос мы&nbsp;и&nbsp;надеемся ответить.

Мы&nbsp;очень постараемся не&nbsp;быть предвзятыми. Будучи членами основной команды разработки Vue, мы, разумеется, сами его очень любим. На&nbsp;наш взгляд, с&nbsp;некоторыми задачами Vue справляется лучше, чем какой-либо другой существующий фреймворк. Если&nbsp;бы мы&nbsp;не&nbsp;верили в&nbsp;это, мы&nbsp;бы наверное и&nbsp;не&nbsp;работали над этим проектом, верно? И&nbsp;тем не&nbsp;менее, нам&nbsp;бы хотелось быть предельно честными и&nbsp;точными в&nbsp;оценках. В&nbsp;тех случаях, когда альтернативные библиотеки имеют существенные преимущества, как например обширнейшая экосистема альтернативных рендереров React&rsquo;а или поддержка браузеров вплоть до&nbsp;IE6 Knockout&rsquo;ом, мы&nbsp;постараемся не&nbsp;забыть о&nbsp;них упомянуть.

Кроме того, мы&nbsp;очень высоко ценим **вашу** помощь в&nbsp;деле поддержания актуальности этого документа, потому что мир JavaScript развивается стремительно! Если вы&nbsp;заметите какую-либо неточность или ошибку&nbsp;&mdash; пожалуйста, дайте нам знать, [открыв issue на&nbsp;Github](https://github.com/vuejs/vuejs.org/issues/new?title=Inaccuracy+in+comparisons+guide).

## React

React и&nbsp;Vue во&nbsp;многом похожи. Они оба:

- используют Virtual DOM
- предоставляют реактивность и&nbsp;компонентную структуру
- фокусируются на&nbsp;корневой библиотеке, вынося прочие вопросы, такие как роутинг или управление глобальным состоянием приложения, в&nbsp;дополнительные библиотеки

Из-за столь похожих ниш, мы&nbsp;уделили сравнению этих фреймворков больше всего времени. Нашей целью было не&nbsp;только удостовериться в&nbsp;технической точности, но&nbsp;также и&nbsp;сохранить баланс. Мы&nbsp;указываем, где React превосходит Vue, например&nbsp;&mdash; в&nbsp;богатстве экосистемы и&nbsp;изобилии доступных пользовательских рендереров.

Тем не&nbsp;менее, многие рассматриваемые моменты&nbsp;&mdash; в&nbsp;известной мере субъективны, и&nbsp;видится неизбежным&nbsp;то, что некоторым пользователям React дальнейшее сравнение всё равно покажется предвзятым. Мы&nbsp;понимаем, что и&nbsp;в&nbsp;технических вопросах существуют элементы вкуса, и&nbsp;в&nbsp;основном ставим своей целью в&nbsp;этом сравнении указать причины, по&nbsp;которым Vue может оказаться вам полезным&nbsp;&mdash; на&nbsp;случай если ваши вкусы совпадают с&nbsp;нашими.

Помощь React-сообщества [была неоценима](https://github.com/vuejs/vuejs.org/issues/364) в&nbsp;деле достижения этого баланса. Особо хотелось&nbsp;бы поблагодарить Даниила Абрамова из&nbsp;команды разработки React. Он&nbsp;был крайне щедр на&nbsp;время и&nbsp;опыт, помогая нам довести этот документ до&nbsp;состояния, когда обе стороны [остались довольны](https://github.com/vuejs/vuejs.org/issues/364#issuecomment-244575740) финальным результатом.

### Сравнение быстродействия

В&nbsp;каждом из&nbsp;реалистичных сценариев, в&nbsp;котором мы&nbsp;проводили тесты, Vue существенно превзошёл React по&nbsp;быстродействию. Если ваши брови сейчас приподнялись, читайте дальше. Мы&nbsp;расскажем, почему (и&nbsp;даже покажем бенчмарк, разработанный вместе с&nbsp;командой React).

#### Быстродействие при рендеринге

При рендеринге&nbsp;UI, манипулирование DOM зачастую оказывается самой дорогой операцией. К&nbsp;сожалению, ни&nbsp;одна библиотека не&nbsp;может ускорить эти низкоуровневые операции. Лучшее, что мы&nbsp;можем сделать&nbsp;&mdash; это:

1. Минимизировать необходимое количество изменений в&nbsp;DOM. Как React, так и&nbsp;Vue используют для этих целей Virtual DOM&nbsp;&mdash; и&nbsp;примерно с&nbsp;равным успехом.
2. Привнести как можно меньше дополнительных накладных расходов в&nbsp;виде JavaScript-операций &laquo;поверх&raquo; манипуляций с&nbsp;DOM. В&nbsp;этой области Vue и&nbsp;React отличаются.

Упомянутые накладные расходы напрямую связаны с&nbsp;механизмами, используемыми для определения операций, необходимых для выполнения с&nbsp;DOM. Как Vue, так и&nbsp;React используют Virtual DOM, но&nbsp;реализация Virtual DOM, используемая во&nbsp;Vue (форк [snabbdom](https://github.com/snabbdom/snabbdom)) значительно более легковесна, и&nbsp;потому привносит меньше накладных расходов по&nbsp;сравнению с&nbsp;используемой в&nbsp;React.

В&nbsp;React, условно говоря, дополнительная трудоёмкость рендеринга элемента равна&nbsp;1, а&nbsp;для компонента&nbsp;&mdash;&nbsp;2. Для Vue эти цифры будут ближе к&nbsp;0.1 и&nbsp;4&nbsp;соответственно. Это значит, что в&nbsp;типичных приложениях, где простых элементов DOM куда больше, чем компонентов, Vue будет существенно обгонять React. В&nbsp;экстремальных&nbsp;же случаях, как например при использовании компонента для каждого HTML-элемента, Vue обычно будет медленнее. Но&nbsp;это ещё не&nbsp;всё.

И&nbsp;Vue, и&nbsp;React позволяют использовать функциональные компоненты, не&nbsp;имеющие ни&nbsp;собственного состояния, ни&nbsp;инстанса&nbsp;&mdash; и&nbsp;потому требующие меньших вычислительных затрат. При использовании таких компонентов в&nbsp;критичных по&nbsp;быстродействию ситуациях, Vue вновь оказывается быстрее. Для демонстрации этого, мы&nbsp;создали простой [бенчмарк](https://github.com/chrisvfritz/vue-render-performance-comparisons), который 100 раз подряд рендерит 10,000 элементов списка. Мы&nbsp;предлагаем вам самим его запустить. Результаты отличаются в&nbsp;зависимости от&nbsp;используемого железа, браузера&nbsp;&mdash; и&nbsp;даже просто от&nbsp;запуска к&nbsp;запуску, в&nbsp;силу природы JavaScript-движков.

Впрочем, если вам лень этим заниматься, вот цифры, полученные при запуске этого теста в&nbsp;Chrome 52&nbsp;на MacBook Air 2014. Таблица обобщает результаты 20&nbsp;запусков:

{% raw %}
<table class="benchmark-table">
  <thead>
    <tr>
      <th></th>
      <th>Vue</th>
      <th>React</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th>Самое быстрое</th>
      <td>23мс</td>
      <td>63мс</td>
    </tr>
    <tr>
      <th>Медиана</th>
      <td>42мс</td>
      <td>81мс</td>
    </tr>
    <tr>
      <th>Среднее</th>
      <td>51мс</td>
      <td>94мс</td>
    </tr>
    <tr>
      <th>95-й перцентиль</th>
      <td>73мс</td>
      <td>164мс</td>
    </tr>
    <tr>
      <th>Самое медленное</th>
      <td>343мс</td>
      <td>453мс</td>
    </tr>
  </tbody>
</table>
{% endraw %}

#### Производительность обновлений

В&nbsp;React, когда состояние компонента изменяется, это вызывает также и&nbsp;перерендеринг всех его потомков. Чтобы избежать излишних операций рендеринга и&nbsp;оптимизировать процесс, необходимо указать метод `shouldComponentUpdate` для каждого компонента, а&nbsp;также использовать иммутабельные структуры данных. Во&nbsp;Vue зависимости автоматически отслеживаются в&nbsp;процессе рендеринга, поэтому системе всегда точно известно, какие элементы нужно обновить.

Это значит, что обновления в&nbsp;приложениях без специально проведённой оптимизации Vue будет показывать значительно лучшую производительность. В&nbsp;действительности, даже полностью оптимизированные React-приложения обычно оказываются медленнее, чем приложения Vue &laquo;из&nbsp;коробки&raquo;.

#### Производительность при разработке

Разумеется, производительность в&nbsp;production важнее всего, поскольку именно она влияет на&nbsp;качество опыта конечных пользователей при взаимодействии с&nbsp;приложением. Но&nbsp;и&nbsp;во&nbsp;время разработки быстродействие используемого фреймворка имеет немалое значение&nbsp;&mdash; она определяет качество опыта разработчика.

И&nbsp;Vue, и&nbsp;React в&nbsp;режиме разработки остаются довольно шустрыми для большей части приложений. Однако, при прототипировании высокопроизводительных визуализаций данных и&nbsp;анимаций, мы&nbsp;обнаружили сценарии, в&nbsp;которых производительность Vue в&nbsp;режиме разработки падала до&nbsp;10&nbsp;кадров в&nbsp;секунду. React в&nbsp;этих&nbsp;же сценариях показал результаты на&nbsp;уровне 1&nbsp;кадра в&nbsp;секунду.

Причина этой разницы лежит во&nbsp;множестве тяжёлых инвариантных проверок, помогающих снабдить разработчиков подробными предупреждениями и&nbsp;сообщениями об&nbsp;ошибках. Мы&nbsp;согласны, что эти сообщения важны&nbsp;&mdash; но&nbsp;во&nbsp;Vue и&nbsp;при их&nbsp;имплементации постарались не&nbsp;забыть о&nbsp;производительности.

### HTML & CSS

В&nbsp;React, абсолютно всё&nbsp;&mdash; это JavaScript. Звучит это заявление очень просто и&nbsp;элегантно&nbsp;&mdash; до&nbsp;тех пор, пока не&nbsp;начнёшь копать глубже. Неприятное свойство реальности заключается в&nbsp;том, что изобретая заново HTML и&nbsp;CSS внутри JavaScript можно испытать немалые страдания. Во&nbsp;Vue&nbsp;мы, напротив, постарались задействовать существующие веб-технологии. Чтобы показать вам, что из&nbsp;этого вышло, мы&nbsp;рассмотрим несколько примеров.

#### JSX vs Шаблоны

В&nbsp;React, все компоненты описывают свой&nbsp;UI посредством render-функций, используя JSX&nbsp;&mdash; декларативный XML-подобный синтаксис, работающий внутри JavaScript. Вот пример, [одобренный сообществом React](https://github.com/vuejs/vuejs.org/issues/364#issuecomment-244582684):

``` jsx
render () {
  let { items } = this.props

  let children
  if (items.length > 0) {
    children = (
      <ul>
        {items.map(item =>
          <li key={item.id}>{item.name}</li>
        )}
      </ul>
    )
  } else {
    children = <p>Ничего не найдено.</p>
  }

  return (
    <div className='list-container'>
      {children}
    </div>
  )
}
```

Render-функции, использующие JSX, имеют определённые преимущества:

- Возможность использовать все алгоритмические возможности JavaScript при создании представления
- Поддержка инструментария (линтинг, проверка типов, автодополнение в&nbsp;редакторах) для JSX зачастую более развита, по&nbsp;сравнению с&nbsp;доступной для шаблонов Vue на&nbsp;данный момент.

Во&nbsp;Vue тоже есть [render-функции](render-function.html), и&nbsp;даже [поддержка JSX](render-function.html#JSX), так как иногда эти возможности действительно нужны. Тем не&nbsp;менее, в&nbsp;качестве более простой альтернативы мы&nbsp;предлагаем большую часть времени использовать шаблоны:

``` html
<template>
  <div class="list-container">
    <ul v-if="items.length">
      <li v-for="item in items">
        {{ item.name }}
      </li>
    </ul>
    <p v-else>Ничего не найдено.</p>
  </div>
</template>
```

Вот некоторые преимущества этого подхода:

- При написании шаблона приходится принимать меньшее количество стилистических решений
- Шаблон всегда остаётся декларативным
- Любой валидный HTML&nbsp;&mdash; это автоматически валидный шаблон
- Читать шаблоны проще, так как они больше похожи на&nbsp;обычный текст на&nbsp;английском языке (напр. for each item in&nbsp;items)
- Для улучшения читабельности кода не&nbsp;требуется использования продвинутых версий JavaScript

Проще становится не&nbsp;только создающим шаблон разработчикам, но&nbsp;и&nbsp;дизайнерам или менее опытным программистам, читающим и&nbsp;правящим его.

Ещё одно преимущество&nbsp;&mdash; возможность использования в&nbsp;шаблонах препроцессоров, таких как Pug (экс-Jade):

``` pug
div.list-container
  ul(v-if="items.length")
    li(v-for="item in items") {{ item.name }}
  p(v-else) Ничего не найдено.
```

#### Модульный (компонентный) CSS

За&nbsp;исключением случаев разделения компонентов на&nbsp;несколько файлов (например, посредством [CSS-модулей](https://github.com/gajus/react-css-modules)), для ограничения области видимости CSS в&nbsp;React обычно используется подход CSS-in-JS. В&nbsp;этой области существует множество соревнующихся решений, каждое с&nbsp;собственными недостатками. Общими проблемами являются такие вопросы как: hover states, media queries, псевдоселекторы&nbsp;&mdash; и&nbsp;эти вопросы зачастую либо требуют использования дополнительных &laquo;тяжёлых&raquo; зависимостей для переизобретения уже существующего в&nbsp;CSS функционала, либо вовсе не&nbsp;работают. Кроме того, без специального внимания к&nbsp;оптимизации, CSS-in-JS может нетривиально повлиять на&nbsp;производительность. Что ещё важнее, использование этих инструментов в&nbsp;любом случае существенно отличается от&nbsp;привычного опыта написания обыкновенного CSS.

Vue&nbsp;же позволяет напрямую использовать CSS в&nbsp;[однофайловых компонентах](single-file-components.html):

``` html
<style scoped>
  @media (min-width: 250px) {
    .list-container:hover {
      background: orange;
    }
  }
</style>
```

Опциональный атрибут `scoped` автоматически ограничивает область видимости CSS текущим компонентом, добавляя элементам уникальные атрибуты (такие как `data-v-1-21e5b78`), и&nbsp;компилируя `.list-container:hover` во&nbsp;что-нибудь вроде `.list-container[data-v-1-21e5b78]:hover`.

Разработчикам, уже знакомым с&nbsp;CSS-модулями мы&nbsp;рады сообщить, что Vue их&nbsp;[полностью поддерживает](http://vue-loader.vuejs.org/en/features/css-modules.html).

Наконец, как и&nbsp;с&nbsp;HTML, у&nbsp;вас есть возможность использования любых препроцессоров (или постпроцессоров) на&nbsp;ваш вкус. Это позволяет применять централизованные операции, такие как управление цветами, на&nbsp;этапе сборки. При этом нет необходимости импортировать специализированные JavaScript-библиотеки, увеличивающие как размер результирующей сборки, так и&nbsp;сложность вашего приложения.


### Масштабирование

#### Масштабирование вверх

Для крупных приложений, как Vue так и&nbsp;React предоставляют надёжные решения для роутинга. Сообщество React также породило весьма инновационные решения в&nbsp;области управления состоянием приложения (см. Flux/Redux). Эти подходы, и&nbsp;[даже сам Redux](https://github.com/egoist/revue) легко интегрируются в&nbsp;приложения на&nbsp;Vue. В&nbsp;действительности, Vue сделал следующий шаг, создав [Vuex](https://github.com/vuejs/vuex)&nbsp;&mdash; вдохновлённую Elm реализацию паттерна управления состоянием приложения. Vuex глубоко интегрирован с&nbsp;Vue, что, на&nbsp;наш взгляд, изрядно облегчает жизнь разработчикам.

В&nbsp;качестве ещё одно важного различия между React и&nbsp;Vue можно упомянуть тот факт, что все дополнительные библиотеки Vue, включая библиотеки для управления состоянием приложения и&nbsp;для роутинга (среди [прочих задач](https://github.com/vuejs)), официально поддерживаются в&nbsp;актуальном соответствии с&nbsp;ядром библиотеки. React, напротив, предпочитает отдать эти вопросы на&nbsp;откуп сообществу, тем самым создавая более фрагментированную экосистему. Впрочем, как уже замечалось ранее, в&nbsp;силу популярности React, его экосистема значительно обширнее, чем у&nbsp;Vue.

Наконец, у&nbsp;Vue есть [инструменты командной строки для генерации проектов](https://github.com/vuejs/vue-cli), упрощающие создание новых проектов с&nbsp;использованием подходящей системы сборки, включая [Webpack](https://github.com/vuejs-templates/webpack), [Browserify](https://github.com/vuejs-templates/browserify), или даже [вовсе без таковой](https://github.com/vuejs-templates/simple). В&nbsp;сообществе React также существуют наработки в&nbsp;этом направлении&nbsp;&mdash; например, [create-react-app](https://github.com/facebookincubator/create-react-app), но&nbsp;на&nbsp;данный момент функционал этого решения имеет ряд ограничений:

- Нет возможности конфигурации проекта в&nbsp;процессе генерации. Vue позволяет Yeoman-подобную настройку шаблонов.
- Существует только один шаблон для одностраничного приложения, в&nbsp;то&nbsp;время как Vue позволяет выбрать подходящий шаблон из&nbsp;довольно широкого их&nbsp;многообразия.
- Нет возможности создавать проекты из&nbsp;пользовательских шаблонов, что может быть особенно полезно для enterprise-окружений с&nbsp;установившимися ранее соглашениями.

Важно заметить, что многие из&nbsp;этих ограничений&nbsp;&mdash; следствия сознательно принятых решений команды create-react-app, и&nbsp;в&nbsp;них есть и&nbsp;свои плюсы. Например, коль скоро ваш проект не&nbsp;требует пользовательской настройки процесса сборки, её&nbsp;можно будет обновлять как зависимость. Прочитать больше об&nbsp;этом подходе [можно здесь](https://github.com/facebookincubator/create-react-app#philosophy).

#### Масштабирование вниз

React известен своей довольно крутой кривой изучения. До&nbsp;того момента, когда новичок сможет что-то написать, ему придётся узнать о&nbsp;JSX, а&nbsp;вероятно&nbsp;&mdash; и&nbsp;о&nbsp;ES2015+, поскольку многие примеры используют синтаксис ES2015-классов. Кроме того придётся разобраться с&nbsp;системами сборки, поскольку, хотя технически и&nbsp;существует возможность использовать Babel самостоятельно для live-компиляции кода, для production этот подход в&nbsp;любом случае не&nbsp;годится.

Vue масштабируется вверх ничуть не&nbsp;хуже (если не&nbsp;лучше), чем React, и&nbsp;в&nbsp;то&nbsp;же время его можно масштабировать и&nbsp;вниз&nbsp;&mdash; вплоть до&nbsp;варианта использования вместе с&nbsp;jQuery. Именно так&nbsp;&mdash; в&nbsp;простейшем случае достаточно просто добавить тег скрипта на&nbsp;HMTL-страницу.

``` html
<script src="https://unpkg.com/vue/dist/vue.js"></script>
```

Начиная с&nbsp;этого момента можно писать код на&nbsp;Vue, и&nbsp;даже использовать production-версию, не&nbsp;мучаясь угрызениями совести и&nbsp;волнениями насчёт производительности.

Поскольку знания JSX, ES2015 и&nbsp;систем сборки не&nbsp;требуется для начала работы с&nbsp;Vue, в&nbsp;среднем у&nbsp;новых разработчиков уходит не&nbsp;больше дня на&nbsp;чтение [руководства](./), позволяющего узнать достаточно для построения нетривиальных приложений.

### Нативный рендеринг

ReactNative позволяет писать нативные приложения для iOS и&nbsp;Android, используя ту&nbsp;же самую модель компонент React&rsquo;а. Это&nbsp;&mdash; прекрасно, так как позволяет разработчикам применить знание одного и&nbsp;того&nbsp;же фреймворка на&nbsp;различных платформах. В&nbsp;этой области, Vue официально поддерживает проект [Weex](https://alibaba.github.io/weex/)&nbsp;&mdash; кросс-платформенный UI-фреймворк, разрабатываемый Alibaba Group и&nbsp;использующий Vue в&nbsp;качестве основного JavaScript-фреймворка. Это значит, что с&nbsp;Weex вы&nbsp;можете использовать тот&nbsp;же синтаксис Vue для создания нативных элементов iOS и&nbsp;Android!

На&nbsp;данный момент Weex всё ещё находится в&nbsp;активной фазе разработки, и&nbsp;ещё не&nbsp;столь матёр и&nbsp;проверен опытом, как ReactNative. Однако, его разработка мотивируется реальными требованиями крупнейшего бизнеса электронной коммерции в&nbsp;мире. Команда разработки Vue также активно взаимодействует с&nbsp;разработчиками Weex, гарантируя отсутствие неожиданностей для Vue-разработчиков.

### Сравнение с MobX

MobX стал довольно популярным в&nbsp;сообществе React. Он&nbsp;использует почти идентичную Vue систему реактивности. В&nbsp;некотором смысле, связку React + MobX можно считать несколько более многословным вариантом Vue, так что если вы&nbsp;используете&nbsp;её, и&nbsp;она вам нравится, переход на&nbsp;Vue может оказаться следующим логичным шагом.

## Angular 1

Некоторые части синтаксиса Vue выглядят очень похоже на&nbsp;синтаксис Angular (например, сравните `v-if` и&nbsp;`ng-if`). Это&nbsp;&mdash; не&nbsp;случайность: многие идеи, лежащие в&nbsp;основе Angular мы&nbsp;считаем верными, и&nbsp;вдохновлялись ими на&nbsp;ранних этапах разработки Vue. Впрочем, в&nbsp;Angular немало и&nbsp;болезненных проблем, и&nbsp;в&nbsp;этих областях мы&nbsp;постарались добиться значительных улучшений.

### Сложность

Vue значительно проще Angular, как в&nbsp;смысле API, так и&nbsp;в&nbsp;смысле архитектуры. Получение достаточных знаний для написания нетривиальных приложений обычно происходит менее чем за&nbsp;день, чего нельзя сказать об&nbsp;Angular.

### Гибкость и модульность

Angular имеет жёсткое мнение насчёт структуры вашего приложения, в&nbsp;то&nbsp;время как Vue проявляет гибкость и&nbsp;является более модульным решением. Хотя это и&nbsp;делает Vue пригодным для большего разнообразия проектов, мы&nbsp;понимаем и&nbsp;то, что когда решения уже приняты за&nbsp;тебя, можно сразу начать программировать, и&nbsp;в&nbsp;этом есть свои преимущества.

По&nbsp;этой причине мы&nbsp;предоставляем [webpack template](https://github.com/vuejs-templates/webpack), позволяющий начать работу уже в&nbsp;течении нескольких минут, давая при этом доступ к&nbsp;таким продвинутым возможностям, как горячая замена модулей, линтинг, извлечение CSS и&nbsp;т.д..

### Связывание данных

Angular использует двунаправленное связывание данных между областями видимости, в&nbsp;то&nbsp;время как Vue концентрируется на&nbsp;однонаправленном потоке данных между компонентами. Это позволяет облегчить понимание потока данных в&nbsp;нетривиальных приложениях.

### Директивы и компоненты

Vue чётче разделяет директивы и&nbsp;компоненты. Директивы предназначены только для инкапсуляции низкоуровневых манипуляций с&nbsp;DOM, в&nbsp;то&nbsp;время как компоненты являют собой полноценные автономные объекты, со&nbsp;своей собственной логикой данных и&nbsp;представления. В&nbsp;Angular эти две концепции в&nbsp;значительной мере смешаны.

### Производительность

Vue производительнее Angular. Кроме того, из-за отсутствия dirty-checking, оптимизировать Vue-приложения намного-намного проще. Angular 1&nbsp;замедляется при увеличении количества наблюдателей, поскольку каждый раз при изменении чего-либо в&nbsp;области видимости все эти наблюдатели должны быть перезапущены. Кроме того, цикл может повториться несколько раз перед стабилизацией, поскольку реакция наблюдателей может спровоцировать следующее обновление. Пользователям Angular нередко приходится прибегать к&nbsp;весьма эзотерическим техникам для обхода этих трудностей, а&nbsp;в&nbsp;некоторых случаях оптимизация и&nbsp;вовсе становится невозможной.

Vue не&nbsp;подвержен таким проблемам по&nbsp;причине использования прозрачного механизма учёта зависимостей с&nbsp;асинхронной очередью&nbsp;&mdash; все изменения рассматриваются независимо, кроме случаев явного указания наличия связи между ними.

Любопытно, что этот подход делает Vue во&nbsp;многом похожим на&nbsp;Angular&nbsp;2.

## Angular 2

Мы&nbsp;выделяем отдельную секцию для Angular&nbsp;2, поскольку по&nbsp;сути он&nbsp;является совершенно новым фреймворком. Например, теперь он&nbsp;содержит полноценную компонентную систему; кроме того, многие детали имплементации были полностью переписаны, а&nbsp;API очень существенно изменился.

### TypeScript

В&nbsp;то&nbsp;время как Angular мог быть использован для небольших приложений, Angular 2&nbsp;переносит акцент в&nbsp;область крупных Enterprise-приложений. Отчасти по&nbsp;этой причине, он&nbsp;почти требует использования TypeScript, что может быть весьма полезно для разработчиков, предпочитающих безопасную типизацию, привычную по&nbsp;языкам вроде Java и&nbsp;C#.

Vue тоже хорошо подходит для [Enterprise-окружений](https://github.com/vuejs/awesome-vue#enterprise-usage) и&nbsp;может использоваться в&nbsp;том числе и&nbsp;с&nbsp;TypeScript с&nbsp;помощью наших [официальных типов](https://github.com/vuejs/vue/tree/dev/types) и&nbsp;[пользовательских декораторов](https://github.com/itsFrank/vue-typescript), что, впрочем, остаётся совершенно необязательной к&nbsp;использованию возможностью.

### Размер и быстродействие

В&nbsp;смысле производительности, оба фреймворка весьма быстры, и&nbsp;пока нет достаточных данных из&nbsp;реального мира чтобы вынести окончательный вердикт. Но&nbsp;если вы&nbsp;всё&nbsp;же хотите цифр, похоже что Vue&nbsp;2.0 всё-таки обгоняет Angular&nbsp;2, по&nbsp;крайней мере если верить этому [стороннему исследованию производительности](http://stefankrause.net/js-frameworks-benchmark4/webdriver-ts/table.html).

Что касается размера, то&nbsp;хотя Angular&nbsp;2 с&nbsp;его оффлайн-компиляцией и&nbsp;возможностями удаления неиспользуемого функционала и&nbsp;может существенно уменьшить свой вес, полнофункциональная сборка Vue&nbsp;2.0, включающая даже компилятор шаблонов&nbsp;(23Кб) всё ещё оказывается значительно легче предельно облегчённой версии Angular&nbsp;2&nbsp;(50Кб). Важно понимать и&nbsp;то, что уменьшение размера Angular&nbsp;2 достигается путём выбрасывания неиспользуемого функционала. Когда этот функционал понадобится&nbsp;&mdash; размер сборки фреймворка может снова возрасти.

### Гибкость

Vue значительно менее упрям, чем Angular&nbsp;2, и&nbsp;поддерживает множество различных систем сборок, не&nbsp;ограничивая разработчиков в&nbsp;том, какую структуру использовать для приложения. Многим программистам эта свобода нравится, хотя есть и&nbsp;те, кто предпочитают иметь единственно-правильный способ построения приложения.

### Кривая обучения

Всё что необходимо для начала работы с&nbsp;Vue&nbsp;&mdash; это знакомство с&nbsp;HTML и&nbsp;обыкновенным (ES5) JavaScript&rsquo;ом. С&nbsp;этими базовыми навыками вы&nbsp;уже можете начать строить нетривиальные приложения после менее чем однодневного прочтения [руководства](./).

Кривая обучения Angular 2&nbsp;значительно круче. Даже без учёта TypeScript, их&nbsp;[руководство по&nbsp;быстрому старту](https://angular.io/docs/js/latest/quickstart.html) начинает с&nbsp;приложения, использующего ES2015 JavaScript и&nbsp;NPM с&nbsp;18&nbsp;зависимостями, 4&nbsp;файлами и&nbsp;более чем 3,000 слов объяснений&nbsp;&mdash; просто для &laquo;Hello World&raquo;. Не&nbsp;будет преувеличением сказать, что [Hello World в&nbsp;исполнении Vue](https://jsfiddle.net/chrisvfritz/50wL7mdz/)&nbsp;&mdash; немного попроще. Возможно по&nbsp;этой причине мы&nbsp;даже не&nbsp;посвящаем ему отдельной страницы в&nbsp;нашем руководстве.

## Ember

Ember&nbsp;&mdash; это полнофункциональный фреймворк, изначально созданный &laquo;имеющим и&nbsp;отстаивающим своё мнение&raquo;. Он&nbsp;требует соблюдения множества соглашений и&nbsp;конвенций, и&nbsp;когда вы&nbsp;с&nbsp;ними освоитесь&nbsp;&mdash; он&nbsp;может сделать вас весьма продуктивными. Однако, это означает ещё и&nbsp;высокую и&nbsp;крутую кривую обучения, не&nbsp;говоря о&nbsp;страдающей гибкости. Выбор между жёстко структурированным фреймворком и&nbsp;библиотекой со&nbsp;слабосвязанными совместно работающими инструментами&nbsp;&mdash; это всегда компромисс. Последняя даёт больше свободы, но&nbsp;и&nbsp;требует принятия большего количества самостоятельных архитектурных решений.

Учитывая вышесказанное, вероятно будет разумнее сравнивать ядро Vue и&nbsp;слои [шаблонизации](https://guides.emberjs.com/v2.7.0/templates/handlebars-basics/) и&nbsp;[объектной модели](https://guides.emberjs.com/v2.7.0/object-model/) Ember:

- Vue предлагает ненавязчивую реактивность для простых JavaScript-объектов и&nbsp;полностью автоматические вычисляемые свойства. В&nbsp;Ember от&nbsp;вас ожидается заворачивание всего в&nbsp;&laquo;Объекты Ember&raquo; и&nbsp;ручное указание зависимостей для вычисляемых свойств.

- Синтаксис шаблонов Vue позволяет использовать все возможности выражений JavaScript, в&nbsp;то&nbsp;время как возможности выражений Handlebars и&nbsp;синтаксис хелперов в&nbsp;Ember намеренно существенно ограничены.

- В&nbsp;вопросах производительности Vue существенно выигрывает&nbsp;&mdash; даже с&nbsp;учётом последнего обновления Glimmer engine в&nbsp;Ember&nbsp;2.0. Vue автоматически объединяет операции обновления, в&nbsp;то&nbsp;время как в&nbsp;Ember требуется ручное управление циклом выполнения в&nbsp;ситуациях, где производительность критична.

## Knockout

Knockout был пионером MVVM-подхода и&nbsp;отслеживания изменений в&nbsp;данных. Его система реактивности очень похожа на&nbsp;используемую Vue. Список [поддерживаемых браузеров](http://knockoutjs.com/documentation/browser-support.html)&nbsp;&mdash; впечатляет, особенно с&nbsp;учётом всех немалых возможностей фреймворка, доступных даже в&nbsp;IE6! Vue&nbsp;же поддерживает только IE9+.

Со&nbsp;временем, впрочем, разработка Knockout замедлилась и&nbsp;он&nbsp;понемногу начал показывать признаки своего возраста. Например, компонентной системе недостаёт полного набора хуков жизненного цикла, а&nbsp;интерфейс передачи дочерних компонентов, хоть и&nbsp;используется очень широко, выглядит по&nbsp;сравнению со&nbsp;[слотами Vue](components.html#Распределение-контента-слотами) не&nbsp;очень выигрышно.

Кроме того, похоже что существует разница в&nbsp;философских подходах к&nbsp;API, которая, если вам интересно, может быть продемонстрирована различиями при создании [простого списка todo](https://gist.github.com/chrisvfritz/9e5f2d6826af00fcbace7be8f6dccb89). Конечно&nbsp;же, это&nbsp;&mdash; субъективный вопрос, но&nbsp;многим API Vue кажется проще и&nbsp;лучше структурированным.

## Polymer

Polymer&nbsp;&mdash; это ещё один проект, спонсируемый Google. В&nbsp;действительности, он&nbsp;тоже послужил источником вдохновения для Vue. Компоненты Vue можно приблизительно сравнивать с&nbsp;пользовательскими элементами Polymer. Стиль разработки с&nbsp;использованием обоих фреймворков довольно похож. Самая существенная разница состоит в&nbsp;том, что Polymer базируется на&nbsp;последних возможностях Web Components и&nbsp;требует для работы использования весьма нетривиальных полифиллов (с&nbsp;потерей быстродействия в&nbsp;браузерах без нативной поддержки эти возможностей). Vue, напротив, без каких-либо зависимостей или полифиллов работает во&nbsp;всех браузерах, начиная с&nbsp;IE9.

В&nbsp;Polymer&nbsp;1.0, разработчики существенно ограничили систему связывания данных для улучшения производительности. Например, единственными поддерживаемыми в&nbsp;шаблонах Polymer выражениями являются булево отрицание и&nbsp;одиночные вызовы методов. Реализация вычисляемых свойств&nbsp;&mdash; тоже не&nbsp;очень гибкая.

Пользовательские элементы Polymer пишутся в&nbsp;HTML-файлах, что ограничивает авторов использованием обыкновенного JavaScript/CSS (и&nbsp;возможностей языка, поддерживаемых браузерами на&nbsp;данный момент). Vue&nbsp;же позволяет использовать в&nbsp;однофайловых компонентах какие угодно пре- и&nbsp;построцессоры, включая, разумеется, и&nbsp;ES2015+.

При работе в&nbsp;production-окружении, Polymer рекомендует загружать всё &laquo;на&nbsp;лету&raquo; при помощи HTML Import&rsquo;ов, что подразумевает как имплементацию этой технологии браузерами, так и&nbsp;поддержку HTTP/2 и&nbsp;сервером, и&nbsp;клиентом. Не&nbsp;для всякой целевой аудитории и&nbsp;не&nbsp;для всякого окружения это может быть выполнимо. В&nbsp;таких случаях предполагается использовать специальный инструмент под названием Vulcanizer, объединяющий элементы Polymer. Vue позволяет комбинировать возможности асинхронной загрузки компонентов c&nbsp;функциями по&nbsp;разделению кода Webpack&rsquo;а, организуя &laquo;ленивую&raquo; загрузку частей приложения. Таким образом мы&nbsp;сохраняем совместимость со&nbsp;старыми браузерами, не&nbsp;теряя производительности на&nbsp;этапе загрузки приложения.

В&nbsp;дальнейшем скорее всего будет возможно углубить интеграцию между компонентами Vue и&nbsp;Web&nbsp;Compoments&nbsp;&mdash; однако пока что мы&nbsp;всё ещё ожидаем стабилизации и&nbsp;взросления спецификации, не&nbsp;озвучивая серьёзных обещаний до&nbsp;момента широкого распространения её&nbsp;поддержки всеми распространёнными браузерами.

## Riot

Riot&nbsp;2.0 предлагает похожую модель разработки, основывающуюся на&nbsp;компонентах (в&nbsp;Riot называемых &laquo;тегами&raquo;), с&nbsp;минималистичным и&nbsp;прекрасно организованным API. Вероятно, Riot и&nbsp;Vue во&nbsp;многом основаны на&nbsp;схожих философских подходах. Однако, несмотря на&nbsp;немного больший размер по&nbsp;сравнению с&nbsp;Riot, Vue имеет некоторые существенные преимущества:

- [Система анимации переходов](transitions.html). У&nbsp;Riot её&nbsp;просто нет.
- Значительно более мощный роутер. API роутинга Riot&rsquo;а&nbsp;&mdash; предельно минималистичен.
- Лучшая производительность. [Несмотря на&nbsp;заявленное](https://github.com/vuejs/vuejs.org/issues/346) использование Virtual DOM, в&nbsp;действительности Riot применяет dirty checking, и&nbsp;потому страдает от&nbsp;тех&nbsp;же проблем, что и&nbsp;Angular&nbsp;1.
- Поддержка более зрелого инструментария. Vue официально поддерживает [Webpack](https://github.com/vuejs/vue-loader), [Browserify](https://github.com/vuejs/vueify), и&nbsp;[SystemJS](https://github.com/vuejs/systemjs-plugin-vue), в&nbsp;то&nbsp;время как Riot полагается в&nbsp;вопросах интеграции с&nbsp;системами сборки на&nbsp;поддержку сообщества.
