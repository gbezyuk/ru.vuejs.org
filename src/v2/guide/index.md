---
title: Введение
type: guide
order: 2
---

## Что такое Vue.js?

Vue (произносится /vjuː/, примерно как **view**)&nbsp;&mdash; это **прогрессивный фреймворк** для создания пользовательских интерфейсов. В&nbsp;отличие от&nbsp;фреймворков-монолитов, Vue создан пригодным для постепенного внедрения. Его ядро в&nbsp;первую очередь решает задачи уровня представления (view), что упрощает интеграцию с&nbsp;другими библиотеками и&nbsp;существующими проектами. С&nbsp;другой стороны, Vue полностью подходит и&nbsp;для создания сложных одностраничных приложений (SPA, Single-Page Applications), если использовать его совместно&nbsp;с [современными инструментами](single-file-components.html) и&nbsp;[дополнительными библиотеками](https://github.com/vuejs/awesome-vue#libraries&mdash;plugins).

Если вы&nbsp;&mdash; опытный фронтенд-разработчик, и&nbsp;хотите узнать, чем Vue отличается от&nbsp;остальных библиотек или фреймворков, обратите внимание&nbsp;на [сравнение с&nbsp;другими фреймворками](comparison.html).

## Начало работы

<p class="tip">В&nbsp;этом официальном руководстве мы&nbsp;предполагаем, что вы&nbsp;уже знакомы с&nbsp;HTML, CSS и&nbsp;JavaScript на&nbsp;базовом уровне. Если&nbsp;же вы&nbsp;во&nbsp;фронтенд-разработке совсем новичок, начинать сразу с&nbsp;изучения фреймворка может быть не&nbsp;лучшей идеей&nbsp;&mdash; возвращайтесь, разобравшись с&nbsp;основами! Наличие опыта работы с&nbsp;другими фреймворками может помочь, но&nbsp;не&nbsp;является обязательным.</p>

Проще всего попробовать Vue.js, начав&nbsp;с [примера Hello World на&nbsp;JSFiddle](https://jsfiddle.net/chrisvfritz/50wL7mdz/). Просто откройте его в&nbsp;другой вкладке, и&nbsp;изменяйте по&nbsp;ходу чтения руководства. А&nbsp;можно и&nbsp;просто создать `.html`-файл на&nbsp;диске и&nbsp;подключить Vue:

``` html
<script src="https://unpkg.com/vue/dist/vue.js"></script>
```

Документация&nbsp;по [установке](installation.html) описывает другие варианты установки Vue. Обратите внимание, что мы&nbsp;**не&nbsp;рекомендуем** новичкам начинать с `vue-cli`, особенно если у&nbsp;них нет опыта работы с&nbsp;инструментами сборки Node.js.

## Декларативный рендеринг

В&nbsp;ядре Vue.js находится система, которая позволяет декларативно отображать данные в&nbsp;DOM, используя простые шаблоны:

``` html
<div id="app">
  {{ message }}
</div>
```
``` js
var app = new Vue({
  el: '#app',
  data: {
    message: 'Hello Vue!'
  }
})
```
{% raw %}
<div id="app" class="demo">
  {{ message }}
</div>
<script>
var app = new Vue({
  el: '#app',
  data: {
    message: 'Hello Vue!'
  }
})
</script>
{% endraw %}

Вот мы&nbsp;и&nbsp;создали наше первое Vue-приложение! Выглядит похоже на&nbsp;простой рендеринг шаблона, но&nbsp;&laquo;под капотом&raquo; Vue выполнил немало работы. Данные и&nbsp;DOM теперь **реактивно** связаны. Как это проверить? Просто откройте консоль JavaScript в&nbsp;своём браузере, и&nbsp;задайте полю `app.message` другое значение. Вы&nbsp;тут&nbsp;же увидите соответствующее изменение в&nbsp;окне браузера.

В&nbsp;дополнение к&nbsp;интерполяции текста, мы&nbsp;можем также связывать атрибуты элементов:

``` html
<div id="app-2">
  <span v-bind:title="message">
    Подержи курсор надо мной пару секунд, чтобы увидеть динамически связанное значение title!
  </span>
</div>
```
``` js
var app2 = new Vue({
  el: '#app-2',
  data: {
    message: 'Вот когда вы загрузили эту страницу: ' + new Date()
  }
})
```
{% raw %}
<div id="app-2" class="demo">
  <span v-bind:title="message">
    Подержи курсор надо мной пару секунд, чтобы увидеть динамически связанное значение title!
  </span>
</div>
<script>
var app2 = new Vue({
  el: '#app-2',
  data: {
    message: 'Вот когда вы загрузили эту страницу: ' + new Date()
  }
})
</script>
{% endraw %}

Здесь мы&nbsp;встречаемся с&nbsp;кое-чем новым. Атрибут `v-bind`, который вы&nbsp;видите, называется **директивой**. Директивы имеют префикс `v-`, указывающий на&nbsp;их&nbsp;особую природу. Как вы&nbsp;уже могли догадаться, они применяют к&nbsp;отображаемому DOM особое реактивное поведение, управляемое Vue. В&nbsp;данном примере директива говорит &laquo;сохраняй значение title этого элемента актуальным при изменении свойства `message` у&nbsp;инстанса Vue&raquo;.

Если вы&nbsp;снова откроете консоль JavaScript и&nbsp;введёте `app2.message = 'какое-то новое сообщение'`, вы&nbsp;опять-таки увидите, что связанный код HTML&nbsp;&mdash; в&nbsp;данном случае, атрибут `title` &mdash; обновился.

## Условия и циклы

Управлять присутствием элемента в&nbsp;DOM тоже довольно просто:

``` html
<div id="app-3">
  <p v-if="seen">Сейчас меня видно</p>
</div>
```

``` js
var app3 = new Vue({
  el: '#app-3',
  data: {
    seen: true
  }
})
```

{% raw %}
<div id="app-3" class="demo">
  <span v-if="seen">Сейчас меня видно</span>
</div>
<script>
var app3 = new Vue({
  el: '#app-3',
  data: {
    seen: true
  }
})
</script>
{% endraw %}

Попробуйте ввести в&nbsp;консоли `app3.seen = false`. Сообщение должно пропасть.

Этот пример демонстрирует возможность связывать данные не&nbsp;только с&nbsp;текстом и&nbsp;атрибутами, но&nbsp;также и&nbsp;со&nbsp;**структурой** DOM. Более того, Vue также имеет мощную систему анимации, которая автоматически применяет [transition-эффекты](transitions.html), когда элементы добавляются/обновляются/удаляются.

Есть несколько других директив, каждая из&nbsp;которых имеет свой особый функционал. Например, директива `v-for` может быть использована для отображения списков, используя данные из&nbsp;массива:

``` html
<div id="app-4">
  <ol>
    <li v-for="todo in todos">
      {{ todo.text }}
    </li>
  </ol>
</div>
```
``` js
var app4 = new Vue({
  el: '#app-4',
  data: {
    todos: [
      { text: 'Посадить дерево' },
      { text: 'Построить дом' },
      { text: 'Вырастить сына' }
    ]
  }
})
```
{% raw %}
<div id="app-4" class="demo">
  <ol>
    <li v-for="todo in todos">
      {{ todo.text }}
    </li>
  </ol>
</div>
<script>
var app4 = new Vue({
  el: '#app-4',
  data: {
    todos: [
      { text: 'Посадить дерево' },
      { text: 'Построить дом' },
      { text: 'Вырастить сына' }
    ]
  }
})
</script>
{% endraw %}

В&nbsp;консоли, введите `app4.todos.push({ text: 'Новый элемент' })`. Вы&nbsp;увидите, что к&nbsp;списку добавился новый элемент.

## Работа с пользовательским вводом

Чтобы пользователи могли взаимодействовать с&nbsp;вашим приложением, используйте директиву `v-on` для наблюдения за&nbsp;событиями, указав метод-обработчик:

``` html
<div id="app-5">
  <p>{{ message }}</p>
  <button v-on:click="reverseMessage">Обратить порядок букв в сообщении</button>
</div>
```
``` js
var app5 = new Vue({
  el: '#app-5',
  data: {
    message: 'Hello Vue.js!'
  },
  methods: {
    reverseMessage: function () {
      this.message = this.message.split('').reverse().join('')
    }
  }
})
```
{% raw %}
<div id="app-5" class="demo">
  <p>{{ message }}</p>
  <button v-on:click="reverseMessage">Обратить порядок букв в сообщении</button>
</div>
<script>
var app5 = new Vue({
  el: '#app-5',
  data: {
    message: 'Hello Vue.js!'
  },
  methods: {
    reverseMessage: function () {
      this.message = this.message.split('').reverse().join('')
    }
  }
})
</script>
{% endraw %}

Обратите внимание, что в&nbsp;методе мы&nbsp;просто обновляем состояние нашего приложения, не&nbsp;трогая DOM&nbsp;&mdash; всю работу с&nbsp;DOM производит Vue, а&nbsp;код, который вы&nbsp;пишете, занимается только логикой приложения.

Vue также содержит директиву `v-model`, позволяющую легко связывать элементы форм и&nbsp;состояние приложения:

``` html
<div id="app-6">
  <p>{{ message }}</p>
  <input v-model="message">
</div>
```
``` js
var app6 = new Vue({
  el: '#app-6',
  data: {
    message: 'Hello Vue!'
  }
})
```
{% raw %}
<div id="app-6" class="demo">
  <p>{{ message }}</p>
  <input v-model="message">
</div>
<script>
var app6 = new Vue({
  el: '#app-6',
  data: {
    message: 'Hello Vue!'
  }
})
</script>
{% endraw %}

## Разбиение приложения на компоненты

Другой важной концепцией Vue являются компоненты. Эта абстракция позволяет собирать большие приложения из&nbsp;меньших кусочков. Компоненты представляют собой пригодные к&nbsp;повторному использованию объекты. Если подумать, почти любой интерфейс может быть представлен как дерево компонентов:

![Дерево Компонентов](/images/components.png)

Во&nbsp;Vue, компонент&nbsp;&mdash; это, по&nbsp;сути, инстанс Vue с&nbsp;предустановленными опциями. Создать новый компонент во&nbsp;Vue просто:

``` js
// Определяем новый компонент под названием todo-item
Vue.component('todo-item', {
  template: '<li>Это todo</li>'
})
```

Теперь его можно использовать в&nbsp;шаблоне другого компонента:

``` html
<ul>
  <!-- Создаём экземпляр компонента todo-item -->
  <todo-item></todo-item>
</ul>
```

Пока что у&nbsp;нас получилось так, что во&nbsp;всех todo будет содержаться один и&nbsp;тот&nbsp;же текст&nbsp;&mdash; это не&nbsp;очень-то интересно. Хотелось&nbsp;бы иметь возможность передать данные от&nbsp;родителя в&nbsp;дочерние компоненты. Давайте изменим определение компонента, чтобы он&nbsp;мог принимать [входной параметр](components.html#Входные-параметры):

``` js
Vue.component('todo-item', {
  // Компонент todo-item теперь принимает
  // "prop", то есть пользовательский параметр.
  // Этот параметр называется todo.
  props: ['todo'],
  template: '<li>{{ todo.text }}</li>'
})
```

Теперь можно передать текст задачи в&nbsp;каждый компонент с&nbsp;помощью `v-bind`:

``` html
<div id="app-7">
  <ol>
    <!-- Теперь мы можем передать каждому todo описание задачи, -->
    <!-- то есть отображать данные динамически                  -->
    <todo-item v-for="item in groceryList" v-bind:todo="item"></todo-item>
  </ol>
</div>
```
``` js
Vue.component('todo-item', {
  props: ['todo'],
  template: '<li>{{ todo.text }}</li>'
})

var app7 = new Vue({
  el: '#app-7',
  data: {
    groceryList: [
      { text: 'Овощи' },
      { text: 'Сыр' },
      { text: 'Что там ещё люди едят?' }
    ]
  }
})
```
{% raw %}
<div id="app-7" class="demo">
  <ol>
    <todo-item v-for="item in groceryList" v-bind:todo="item"></todo-item>
  </ol>
</div>
<script>
Vue.component('todo-item', {
  props: ['todo'],
  template: '<li>{{ todo.text }}</li>'
})
var app7 = new Vue({
  el: '#app-7',
  data: {
    groceryList: [
      { text: 'Овощи' },
      { text: 'Сыр' },
      { text: 'Что там ещё люди едят?' }
    ]
  }
})
</script>
{% endraw %}

Конечно&nbsp;же, этот пример слегка надуман, но&nbsp;посмотрите сами&nbsp;&mdash; нам удалось разделить наше приложение на&nbsp;два меньших объекта, и&nbsp;дочерний оказался в&nbsp;разумной мере отвязан от&nbsp;родительского с&nbsp;помощью интерфейса входных параметров. Теперь мы&nbsp;можем и&nbsp;далее улучшать наш компонент `<todo-item>`, усложняя шаблон и&nbsp;логику, но&nbsp;не&nbsp;влияя на&nbsp;родительское приложение.

В&nbsp;крупных приложениях разделение на&nbsp;компоненты становится обязательным условием для сохранения управляемости процесса разработки. Разговор о&nbsp;компонентах ещё далеко не&nbsp;закончен и&nbsp;будет продолжен [далее в&nbsp;этом руководстве](components.html), но&nbsp;уже сейчас можно взглянуть&nbsp;на (вымышленный) пример того, как мог&nbsp;бы выглядеть шаблон приложения, использующего компоненты:

``` html
<div id="app">
  <app-nav></app-nav>
  <app-view>
    <app-sidebar></app-sidebar>
    <app-content></app-content>
  </app-view>
</div>
```

### Отношение к пользовательским элементам Web Components

Вы&nbsp;могли заметить, что компоненты Vue довольно похожи на&nbsp;**пользовательские элементы**, являющиеся частью [спецификации W3C Web Components](http://www.w3.org/wiki/WebComponents/). Дело в&nbsp;том, что синтаксис компонентов Vue и&nbsp;правда намеренно следует этой спецификации. В&nbsp;частности, компоненты Vue реализуют [API слотов](https://github.com/w3c/webcomponents/blob/gh-pages/proposals/Slots-Proposal.md) и&nbsp;специальный атрибут `is`. Вместе с&nbsp;тем, есть и&nbsp;несколько ключевых различий:

1. Спецификация Web Components всё ещё находится в&nbsp;статусе черновика и&nbsp;не&nbsp;реализована ни&nbsp;в&nbsp;одном из&nbsp;браузеров. Компоненты Vue, напротив, не&nbsp;требуют никаких полифиллов и&nbsp;устойчиво работают во&nbsp;всех поддерживаемых браузерах (IE9 и&nbsp;выше). При необходимости компоненты Vue могут быть обёрнуты в&nbsp;нативные пользовательские элементы.

2. Компоненты Vue предоставляют важные возможности, недоступные в&nbsp;простых пользовательских элементах. Самые важные из&nbsp;них: кросс-компонентная передача данных, коммуникация с&nbsp;использованием пользовательских событий и&nbsp;интеграция с&nbsp;инструментами создания сборок.

## Готовы к большему?

Мы&nbsp;всего лишь кратко представили самые основные возможности ядра Vue.js&nbsp;&mdash; остаток этого руководства посвящён значительно более детальному рассмотрению этих и&nbsp;других возможностей, так что советуем прочитать его целиком!
