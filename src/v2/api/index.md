---
title: API
type: api
---

## Глобальные параметры

`Vue.config` &mdash; это объект, содержащий глобальные параметры Vue. Перед загрузкой приложения можно изменить следующие свойства:

### silent

- **Тип:** `boolean`

- **По умолчанию:** `false`

- **Использование:**

  ``` js
  Vue.config.silent = true
  ```

  Отключает вывод логов и&nbsp;предупреждений Vue.

### optionMergeStrategies

- **Тип:** `{ [key: string]: Function }`

- **По умолчанию:** `{}`

- **Использование:**

  ``` js
  Vue.config.optionMergeStrategies._my_option = function (parent, child, vm) {
    return child + 1
  }

  const Profile = Vue.extend({
    _my_option: 1
  })

  // Profile.options._my_option = 2
  ```

  Меняет стратегию слияния опций на&nbsp;вашу собственную.

  Стратегия слияния получает значения опции родительского и&nbsp;дочернего элемента первым и&nbsp;вторым параметром соответственно.
  Третьим параметром передаётся контекст действующего экземпляра Vue.

- **См. также:** [Пользовательские стратегии слияния опций](../guide/mixins.html#Пользовательские-стратегии-слияния-опций)

### devtools

- **Тип:** `boolean`

- **По умолчанию:** `true` (`false` в production-сборках)

- **Использование:**

  ``` js
  // убедитесь, что устанавливаете это свойство синхронно сразу после загрузки Vue
  Vue.config.devtools = true
  ```

  Указывает, должен&nbsp;ли Vue позволять [Vue-devtools](https://github.com/vuejs/vue-devtools) проводить инспекцию. Значение по&nbsp;умолчанию для development-окружения&nbsp;&mdash; `true`, для production-сборок&nbsp;&mdash; `false`. Установите `true`, чтобы vue-devtools работал и&nbsp;в&nbsp;production.

### errorHandler

- **Тип:** `Function`

- **По умолчанию:** Ошибка выбрасывается "на месте"

- **Использование:**

  ``` js
  Vue.config.errorHandler = function (err, vm) {
    // обработка ошибки
  }
  ```

  Устанавливает обработчик для ошибок, не&nbsp;пойманных во&nbsp;время рендеринга компонентов и&nbsp;в&nbsp;наблюдателях. Обработчик получит в&nbsp;параметрах ошибку и&nbsp;действующий экземпляр Vue.

  > Сервис отслеживания ошибок [Sentry](https://sentry.io) предлагает [официальную интеграцию](https://sentry.io/for/vue/) с&nbsp;использованием этого свойства.

### ignoredElements

- **Тип:** `Array<string>`

- **По умолчанию:** `[]`

- **Использование:**

  ``` js
  Vue.config.ignoredElements = [
    'my-custom-web-component', 'another-web-component'
  ]
  ```

  Позволяет Vue игнорировать пользовательские компоненты, установленные за&nbsp;пределами Vue (например, используя Web&nbsp;Components API). Иначе возникнет предупреждение о&nbsp;&laquo;Неизвестном пользовательском элементе&raquo;, означающее, что вы&nbsp;забыли зарегистрировать глобальный компонент или допустили ошибку в&nbsp;написании имени компонента.

### keyCodes

- **Тип:** `{ [key: string]: number | Array<number> }`

- **По умолчанию:** `{}`

- **Использование:**

  ``` js
  Vue.config.keyCodes = {
    v: 86,
    f1: 112,
    mediaPlayPause: 179,
    up: [38, 87]
  }
  ```

  Определение пользовательских псевдонимов для директивы `v-on`.

## Глобальный API

<h3 id="Vue-extend">Vue.extend( options )</h3>

- **Аргументы:**
  - `{Object} options`

- **Использование:**

  Создаёт &laquo;подкласс&raquo; базового конструктора Vue. Принимает параметром объект с&nbsp;опциями нового компонента.

  Внимание: у&nbsp;объекта, переданного в `Vue.extend()` свойство `data` должно быть функцией.

  ``` html
  <div id="mount-point"></div>
  ```

  ``` js
  // Создание конструктора
  var Profile = Vue.extend({
    template: '<p>{{firstName}} {{lastName}}, также известный как {{alias}}</p>',
    data: function () {
      return {
        firstName: 'Уолтер',
        lastName: 'Уайт',
        alias: 'Гейзенберг'
      }
    }
  })
  // создаёт экземпляр Profile и монтирует его к элементу DOM
  new Profile().$mount('#mount-point')
  ```

  Результатом будет:

  ``` html
  <p>Уолтер Уайт, также известный как Гейзенберг</p>
  ```

- **См. также:** [Компоненты](../guide/components.html)

<h3 id="Vue-nextTick">Vue.nextTick( [callback, context] )</h3>

- **Аргументы:**
  - `{Function} [callback]`
  - `{Object} [context]`

- **Использование:**

  Выполняет функцию `callback` при следующем цикле обновления DOM. Вызывайте сразу после изменения данных, чтобы работать с&nbsp;обновлённым DOM.

  ``` js
  // изменение данных
  vm.msg = 'Привет'
  // DOM ещё не обновлён
  Vue.nextTick(function () {
    // теперь DOM обновлён
  })
  ```

  > Добавлено в&nbsp;версии 2.1.0: возвращает `Promise`, если окружение их&nbsp;поддерживает и&nbsp;коллбэк не&nbsp;указан.

- **См. также:** [Асинхронная очередь обновлений](../guide/reactivity.html#Асинхронная-очередь-обновлений)


<h3 id="Vue-set">Vue.set( object, key, value )</h3>

- **Аргументы:**
  - `{Object} object`
  - `{string} key`
  - `{any} value`

- **Возвращает:** установленное значение.

- **Использование:**

  Меняет значение поля. Если объект реактивный, поле тоже станет реактивным, а&nbsp;шаблон обновится. Обычно нужен, потому что Vue не&nbsp;может среагировать на&nbsp;неявное добавление полей.

  **Обратите внимание что объект не&nbsp;может быть экземпляром Vue или корневым объектом data экземпляра Vue.**

- **См. также:** [Подробно о реактивности](../guide/reactivity.html)

<h3 id="Vue-delete">Vue.delete( object, key )</h3>

- **Аргументы:**
  - `{Object} object`
  - `{string} key`

- **Использование:**

  Удаляет поле. Если объект реактивный, шаблон обновится. Обычно нужен, потому что Vue не&nbsp;может среагировать на&nbsp;неявное удаление полей (но&nbsp;вам редко когда это понадобится).

  **Обратите внимание что объект не&nbsp;может быть экземпляром Vue или корневым объектом data экземпляра Vue.**

- **См. также:** [Подробно о реактивности](../guide/reactivity.html)

<h3 id="Vue-directive">Vue.directive( id, [definition] )</h3>

- **Аргументы:**
  - `{string} id`
  - `{Function | Object} [definition]`

- **Использование:**

  Регистрирует новую глобальную директиву или возвращает уже зарегистрированную.

  ``` js
  // регистрируем директиву-объект:
  Vue.directive('my-directive', {
    bind: function () {},
    inserted: function () {},
    update: function () {},
    componentUpdated: function () {},
    unbind: function () {}
  })

  // региструем директиву в виде простой функции:
  Vue.directive('my-directive', function () {
    // Vue будет вызывать эту функцию как `bind` и `update`
  })

  // получаем определение директивы, если она зарегистрирована:
  var myDirective = Vue.directive('my-directive')
  ```

- **См. также:** [Пользовательские директивы](../guide/custom-directive.html)

<h3 id="Vue-filter">Vue.filter( id, [definition] )</h3>

- **Аргументы:**
  - `{string} id`
  - `{Function} [definition]`

- **Использование:**

  Регистрирует новый глобальный фильтр или возвращает уже зарегистрированный.

  ``` js
  // регистрируем фильтр:
  Vue.filter('my-filter', function (value) {
    // возвращаем обработанное значение
  })

  // получаем фильтр, если он зарегистрирован:
  var myFilter = Vue.filter('my-filter')
  ```

<h3 id="Vue-component">Vue.component( id, [definition] )</h3>

- **Аргументы:**
  - `{string} id`
  - `{Function | Object} [definition]`

- **Использование:**

  Регистрирует новый глобальный компонент или возвращает уже зарегистрированный. Регистрация также автоматически установит свойство `name` компонента равным переданному `id`.

  ``` js
  // регистрируем конструктор, полученный из Vue.extend:
  Vue.component('my-component', Vue.extend({ /* ... */ }))

  // регистрируем объект с опциями (Vue вызовет для этого объекта Vue.extend автоматически):
  Vue.component('my-component', { /* ... */ })

  // получаем зарегистрированный компонент (всегда вернёт конструктор):
  var MyComponent = Vue.component('my-component')
  ```

- **См. также:** [Компоненты](../guide/components.html)

<h3 id="Vue-use">Vue.use( plugin )</h3>

- **Аргументы:**
  - `{Object | Function} plugin`

- **Использование:**

  Устанавливает плагин Vue.js. Если плагин&nbsp;&mdash; объект, у&nbsp;него должен быть публичный метод `install`. Если плагин&nbsp;&mdash; функция, она будет воспринята как метод `install`. Этот метод будет выполнен с&nbsp;Vue в&nbsp;качестве аргумента.

  Плагин будет установлен только один раз, независимо от&nbsp;количества вызовов этого метода с&nbsp;одним и&nbsp;тем&nbsp;же плагином.

- **См. также:** [Плагины](../guide/plugins.html)

<h3 id="Vue-mixin">Vue.mixin( mixin )</h3>

- **Аргументы:**
  - `{Object} mixin`

- **Использование:**

  Применяет примесь ко&nbsp;всем созданным впоследствии экземплярам Vue. Так авторы плагинов могут встроить желаемое поведение в&nbsp;компоненты. **Не&nbsp;рекомендуется использовать в&nbsp;коде приложений**.

- **См. также:** [Глобальные примеси](../guide/mixins.html#Глобальные-примеси)

<h3 id="Vue-compile">Vue.compile( template )</h3>

- **Аргументы:**
  - `{string} template`

- **Использование:**

  Компилирует строковый шаблон в&nbsp;`render`-функцию. **Доступен только в&nbsp;standalone-сборке.**

  ``` js
  var res = Vue.compile('<div><span>{{ msg }}</span></div>')

  new Vue({
    data: {
      msg: 'hello'
    },
    render: res.render,
    staticRenderFns: res.staticRenderFns
  })
  ```

- **См. также:** [Render-функции](../guide/render-function.html)

## Опции — данные

### data

- **Тип:** `Object | Function`

- **Ограничение:** При создании компонента, может быть только типа `Function`.

- **Подробности:**

  Объект с&nbsp;данными экземпляра Vue. Vue рекурсивно переводит его поля в&nbsp;геттеры/сеттеры, и&nbsp;он&nbsp;становится &laquo;реактивным&raquo;. **Объект должен быть простым**: Vue проигнорирует свойства прототипа и&nbsp;нативные объекты, как например из&nbsp;API браузера. Прежде всего, рекомендуем чтобы данные были просто данными&nbsp;&mdash; не&nbsp;стоит передавать сюда объекты с&nbsp;собственным управлением внутренним состоянием.

  Добавлять реактивные свойства к&nbsp;корневому объекту данных после его инициализации нельзя. Поэтому определяйте корневые реактивные свойства до&nbsp;создания экземпляра.

  После создания экземпляра, объект с&nbsp;данными доступен в `vm.$data`. Кроме того, экземпляр Vue проксирует обнаруженные в&nbsp;нём свойства, так что `vm.a` эквивалентно `vm.$data.a`.

  Свойства, названия которых начинается с `_` или `$` **не&nbsp;проксируются** из-за возможных конфликтов со&nbsp;внутренними свойствами и&nbsp;методами API Vue. Доступ к&nbsp;таким свойствам возможен только через `vm.$data._property`.

  Для определения **компонента** опция `data` должна быть функцией, возвращающей объект для инициализации, потому что из&nbsp;одного определения компонента может быть создано несколько экземпляров. Если&nbsp;бы мы&nbsp;использовали для `data` простой объект, все созданные экземпляры получили&nbsp;бы **ссылку на&nbsp;него**! А&nbsp;когда `data` &mdash; функция, при создании нового экземпляра можно вызвать её&nbsp;и&nbsp;получить свежую копию данных для инициализации.

  Чтобы получить полную копию оригинального объекта, передайте `vm.$data` в&nbsp;`JSON.parse(JSON.stringify(...))`.

- **Пример:**

  ``` js
  var data = { a: 1 }

  // создаём экземпляр напрямую:
  var vm = new Vue({
    data: data
  })
  vm.a // -> 1
  vm.$data === data // -> true

  // обязательно используйте функцию во Vue.extend():
  var Component = Vue.extend({
    data: function () {
      return { a: 1 }
    }
  })
  ```

  <p class="tip">Обратите внимание, что __вам не&nbsp;стоит использовать стрелочные функции в&nbsp;параметре `data`__ (напр. `data: () => { return { a: this.myProp }}`). Поскольку стрелочные функции связываются с&nbsp;родительским контекстом, `this` не&nbsp;будет указывать на&nbsp;экземпляр Vue и&nbsp;`this.myProp` окажется неопределённым.</p>

- **См. также:** [Подробно о реактивности](../guide/reactivity.html)

### props

- **Тип:** `Array<string> | Object`

- **Подробности:**

  Список или хэш атрибутов, по&nbsp;которым разрешено получение данных от&nbsp;родительского компонента. Передайте простой массив названий или объект, задающий дополнительные параметры, например типы, правила валидации и&nbsp;значения по&nbsp;умолчанию.

- **Пример:**

  ``` js
  // простая форма записи:
  Vue.component('props-demo-simple', {
    props: ['size', 'myMessage']
  })

  // объект с указанием правил валидации:
  Vue.component('props-demo-advanced', {
    props: {
      // только проверка типа
      height: Number,
      // проверка типа и другие правила валидации
      age: {
        type: Number,
        default: 0,
        required: true,
        validator: function (value) {
          return value >= 0
        }
      }
    }
  })
  ```

- **См. также:** [Входные параметры](../guide/components.html#Входные-параметры)

### propsData

- **Тип:** `{ [key: string]: any }`

- **Ограничение:** учитывается только при создании экземпляра выражением `new`.

- **Подробности:**

  Параметры компонента при его создании. Обычно используются для облегчения модульного тестирования.

- **Пример:**

  ``` js
  var Comp = Vue.extend({
    props: ['msg'],
    template: '<div>{{ msg }}</div>'
  })

  var vm = new Comp({
    propsData: {
      msg: 'привет'
    }
  })
  ```

### computed

- **Тип:** `{ [key: string]: Function | { get: Function, set: Function } }`

- **Подробности:**

  Вычисляемые свойства, которые будут подмешаны к&nbsp;экземпляру Vue. В&nbsp;геттерах и&nbsp;сеттерах `this` будет указывать на&nbsp;экземпляр Vue.

  <p class="tip">Обратите внимание, что __вам не&nbsp;стоит использовать стрелочные функции при определении вычисляемых свойств__ (напр. `aDouble: () => this.a * 2`). Поскольку стрелочные функции связываются с&nbsp;родительским контекстом, `this` не&nbsp;будет указывать на&nbsp;экземпляр Vue, и&nbsp;`this.a` окажется неопределённым.</p>

  Вычисляемые свойства кешируются и&nbsp;повторно вычисляются только при изменении реактивных зависимостей.

- **Пример:**

  ```js
  var vm = new Vue({
    data: { a: 1 },
    computed: {
      // если свойство только возвращает данные, достаточно простой функции:
      aDouble: function () {
        return this.a * 2
      },
      // свойство и возвращает, и получает данные:
      aPlus: {
        get: function () {
          return this.a + 1
        },
        set: function (v) {
          this.a = v - 1
        }
      }
    }
  })
  vm.aPlus   // -> 2
  vm.aPlus = 3
  vm.a       // -> 2
  vm.aDouble // -> 4
  ```

- **См. также:**
  - [Вычисляемые свойства](../guide/computed.html)

### methods

- **Тип:** `{ [key: string]: Function }`

- **Подробности:**

  Методы, которые будут подмешаны к&nbsp;экземпляру Vue. Вы&nbsp;можете запустить эти методы прямо из&nbsp;экземпляра&nbsp;vm, или использовать их&nbsp;в&nbsp;директивах. `this` методов указывает на&nbsp;экземпляр Vue.

  <p class="tip">Обратите внимание, что __вам не&nbsp;стоит использовать стрелочные функции при определении методов__ (напр. `plus: () => this.a++`). Поскольку стрелочные функции связываются с&nbsp;родительским контекстом, `this` не&nbsp;будет указывать на&nbsp;экземпляр Vue, и&nbsp;`this.a` окажется неопределённым.</p>

- **Пример:**

  ```js
  var vm = new Vue({
    data: { a: 1 },
    methods: {
      plus: function () {
        this.a++
      }
    }
  })
  vm.plus()
  vm.a // 2
  ```

- **См. также:** [Обработка событий](../guide/events.html)

### watch

- **Тип:** `{ [key: string]: string | Function | Object }`

- **Подробности:**

  Объект, ключи которого&nbsp;&mdash; выражения для наблюдения, а&nbsp;значения&nbsp;&mdash; коллбэки, вызываемые при их&nbsp;изменении. Значения также могут строками с&nbsp;именами методов, или объектами, содержащими дополнительные опции. Экземпляр Vue вызовет `$watch()` соответствующий каждому ключу объекта при своём создании.

- **Пример:**

  ``` js
  var vm = new Vue({
    data: {
      a: 1,
      b: 2,
      c: 3
    },
    watch: {
      a: function (val, oldVal) {
        console.log('новое значение: %s, старое значение: %s', val, oldVal)
      },
      // строка с именем метода:
      b: 'someMethod',
      // глубокий (рекурсивный) наблюдатель:
      c: {
        handler: function (val, oldVal) { /* ... */ },
        deep: true
      }
    }
  })
  vm.a = 2 // -> new: 2, old: 1
  ```

  <p class="tip">Обратите внимание, что __вам не&nbsp;стоит использовать стрелочные функции при определении наблюдателей__ (напр. `searchQuery: newValue => this.updateAutocomplete(newValue)`). Поскольку стрелочные функции связываются с&nbsp;родительским контекстом, `this` не&nbsp;будет указывать на&nbsp;экземпляр Vue, и&nbsp;`this.updateAutocomplete` окажется неопределённым.</p>

- **См. также:** [Методы экземпляра — vm.$watch](#vm-watch)

## Опции — DOM

### el

- **Тип:** `string | HTMLElement`

- **Ограничение:** учитывается только при создании экземпляра выражением `new`.

- **Подробности:**

  Указывает, на&nbsp;какой существующий DOM-элемент смонтировать экземпляр Vue. Может быть строковым CSS-селектором или собственно объектом типа HTMLElement.

  После монтирования экземпляра, переданный или найденный по&nbsp;CSS-селектору элемент будет доступен в&nbsp;`vm.$el`.

  Если эта опция указана при создании экземпляра, компиляция начнётся сразу&nbsp;же. В&nbsp;остальных случаях, вызовите `vm.$mount()`, чтобы запустить компиляцию.

  <p class="tip">Указанный элемент служит только точкой монтирования. В&nbsp;отличии от&nbsp;Vue&nbsp;1.x, он&nbsp;обязательно будет заменён DOM-ом, сгенерированным Vue. Поэтому не&nbsp;стоит монтировать в&nbsp;корневые элементы `<html>` или `<body>`.</p>

- **См. также:** [Диаграмма жизненного цикла](../guide/instance.html#Диаграмма-жизненного-цикла)

### template

- **Тип:** `string`

- **Подробности:**

  Строковый шаблон с&nbsp;разметкой для экземпляра Vue. Этот шаблон **заменит** элемент в&nbsp;точке монтирования. Вся уже существующая разметка в&nbsp;точке монтирования будет проигнорирована, если в&nbsp;шаблоне нет слота распределения контента.

  Если строка начинается с&nbsp;`#`, она будет использована как querySelector, а&nbsp;в&nbsp;качестве строкового шаблона будет использован innerHTML элемента с&nbsp;указанным&nbsp;id. Так вы&nbsp;сможете включать шаблоны, из&nbsp;тегов вроде `<script type="x-template">`.

  <p class="tip">С&nbsp;точки зрения безопасности необходимо использовать только те&nbsp;шаблоны Vue, которым вы&nbsp;можете доверять. Никогда не&nbsp;используйте в&nbsp;качестве шаблона данные, вводимые пользователем.</p>

- **См. также:**
  - [Диаграмма жизненного цикла](../guide/instance.html#Диаграмма-жизненного-цикла)
  - [Распределение контента слотами](../guide/components.html#Распределение-контента-слотами)

### render

  - **Тип:** `Function`

  - **Подробности:**

  Альтернатива строковым шаблонам, позволяющая задействовать все алгоритмические возможности JavaScript. `Render`-функция получает первым аргументом метод `createElement`, нужный для создания `VNode`-ов.

  Если компонент функциональный, вторым параметром передаётся `context`, дающий доступ к&nbsp;контекстным данным, так как функциональные компоненты не&nbsp;имеют экземпляров.

  - **См. также:**
    - [Render-функции](../guide/render-function.html)

## Опции — хуки жизненного цикла

Хук (hook&nbsp;&mdash; буквально &laquo;крючок&raquo;), функция, вызывающаяся в&nbsp;определённый момент жизненного цикла сущности, например, непосредственно перед или после создания компонента Vue. Хук позволяет расширить или изменить стандартное поведение на&nbsp;пользовательское.

Контекст `this` хуков указывает на&nbsp;экземпляр Vue c&nbsp;данными, вычисляемыми свойствами и&nbsp;методами. Это значит, что __вам не&nbsp;следует использовать стрелочные функции для определения хуков жизненного цикла__ (напр. `created: () => this.fetchTodos()`). Поскольку стрелочные функции связываются с&nbsp;родительским контекстом, `this` не&nbsp;будет указывать на&nbsp;экземпляр Vue, и&nbsp;`this.fetchTodos` окажется неопределённым.

### beforeCreate

- **Тип:** `Function`

- **Подробности:**

  Вызывается синхронно сразу после инициализации экземпляра, до&nbsp;настройки наблюдения за&nbsp;данными, механизмов слежения и&nbsp;событий.

- **См. также:** [Диаграмма жизненного цикла](../guide/instance.html#Диаграмма-жизненного-цикла)

### created

- **Тип:** `Function`

- **Подробности:**

  Вызывается синхронно сразу после создания экземпляра. На&nbsp;этом этапе экземпляр закончил обработку опций и&nbsp;настроил наблюдение за&nbsp;данными, вычисляемые свойства, методы, коллбэки слежения и&nbsp;событий. Однако, фаза монтирования ещё не&nbsp;начата, и&nbsp;свойство `$el` ещё не&nbsp;доступно.

- **См. также:** [Диаграмма жизненного цикла](../guide/instance.html#Диаграмма-жизненного-цикла)

### beforeMount

- **Тип:** `Function`

- **Подробности:**

  Вызывается перед началом монтирования, сразу перед первым вызовом функции `render`.

  **При рендеринге на&nbsp;стороне сервера этот хук не&nbsp;вызывается.**

- **См. также:** [Диаграмма жизненного цикла](../guide/instance.html#Диаграмма-жизненного-цикла)

### mounted

- **Тип:** `Function`

- **Подробности:**

  Вызывается сразу после того как экземпляр был смонтирован, а&nbsp;взамен `el` создан `vm.$el`. Если корневой экземпляр смонтирован на&nbsp;элемент документа, `vm.$el` тоже будет элементом документа.

  **При рендеринге на&nbsp;стороне сервера этот хук не&nbsp;вызывается.**

- **См. также:** [Диаграмма жизненного цикла](../guide/instance.html#Диаграмма-жизненного-цикла)

### beforeUpdate

- **Тип:** `Function`

- **Подробности:**

  Вызывается при изменении данных, до&nbsp;повторного рендеринга и&nbsp;обновления виртуального DOM-а.

  В&nbsp;этом хуке можно дополнительно изменять состояние, и&nbsp;это не&nbsp;вызовет нового повторного рендеринга.

  **При рендеринге на&nbsp;стороне сервера этот хук не&nbsp;вызывается.**

- **См. также:** [Диаграмма жизненного цикла](../guide/instance.html#Диаграмма-жизненного-цикла)

### updated

- **Тип:** `Function`

- **Подробности:**

  Вызывается после того, как виртуальный DOM был обновлён из-за изменения данных.

  DOM компонента уже будет обновлён к&nbsp;моменту вызова этого хука, поэтому можно выполнять зависящие от&nbsp;DOM операции. Старайтесь избегать изменения состояния в&nbsp;этом хуке, чтобы не&nbsp;попасть в&nbsp;бесконечный цикл обновления.

  **При рендеринге на&nbsp;стороне сервера этот хук не&nbsp;вызывается.**

- **См. также:** [Диаграмма жизненного цикла](../guide/instance.html#Диаграмма-жизненного-цикла)

### activated

- **Тип:** `Function`

- **Подробности:**

  Вызывается при активации keep-alive компонента.

  **При рендеринге на стороне сервера этот хук не&nbsp;вызывается.**

- **См. также:**
  - [Встроенные компоненты — keep-alive](#keep-alive)
  - [Динамические компоненты — keep-alive](../guide/components.html#keep-alive)

### deactivated

- **Тип:** `Function`

- **Подробности:**

  Вызывается после деактивации keep-alive компонента.

  **При рендеринге на стороне сервера этот хук не&nbsp;вызывается.**

- **См. также:**
  - [Встроенные компоненты — keep-alive](#keep-alive)
  - [Динамические компоненты — keep-alive](../guide/components.html#keep-alive)

### beforeDestroy

- **Тип:** `Function`

- **Подробности:**

  Вызывается перед уничтожением экземпляра Vue. На&nbsp;этом этапе экземпляр всё ещё полностью функционален.

  **При рендеринге на&nbsp;стороне сервера этот хук не&nbsp;вызывается.**

- **См. также:** [Диаграмма жизненного цикла](../guide/instance.html#Диаграмма-жизненного-цикла)

### destroyed

- **Тип:** `Function`

- **Подробности:**

  Вызывается после уничтожения экземпляра Vue. К&nbsp;моменту вызова этого хука, все директивы экземпляра Vue уже отвязаны, все подписчики событий удалены, а&nbsp;все дочерние экземпляры Vue уничтожены.

  **При рендеринге на&nbsp;стороне сервера этот хук не&nbsp;вызывается.**

- **См. также:** [Диаграмма жизненного цикла](../guide/instance.html#Диаграмма-жизненного-цикла)

## Опции — ресурсы

### directives

- **Тип:** `Object`

- **Подробности:**

  Хэш директив, доступных экземпляру Vue.

- **См. также:**
  - [Пользовательские директивы](../guide/custom-directive.html)
  - [Соглашение по именованию компонентов](../guide/components.html#Соглашения-по-именованию-компонентов)

### filters

- **Тип:** `Object`

- **Подробности:**

  Хэш фильтров, доступных экземпляру Vue.

- **См. также:**
  - [`Vue.filter`](#Vue-filter)

### components

- **Тип:** `Object`

- **Подробности:**

  Хэш компонентов, доступных экземпляру Vue.

- **См. также:**
  - [Компоненты](../guide/components.html)

## Опции — разное

### parent

- **Тип:** `экземпляр Vue`

- **Подробности:**

  Определяет родительский экземпляр для создаваемого. Устанавливает отношение &laquo;родитель-потомок&raquo; между ними. Родитель будет доступен дочернему экземпляру посредством `this.$parent`, а&nbsp;дочерний экземпляр будет добавлен в&nbsp;массив `$children` родителя.

  <p class="tip">Старайтесь реже использовать `$parent` и&nbsp;`$children`&nbsp;&mdash; этот механизм мы&nbsp;предусмотрели на&nbsp;крайний случай. Для общения между родителем и&nbsp;ребёнком лучше использовать свойства и&nbsp;события.</p>

### mixins

- **Тип:** `Array<Object>`

- **Подробности:**

  Массив объектов-примесей. Примеси могут содержать те&nbsp;же опции, что и&nbsp;обычные объекты экземпляров Vue&nbsp;&mdash; они будут добавлены к&nbsp;основным опциям согласно логике `Vue.extend()`. Например, если и&nbsp;примесь и&nbsp;объект экземпляра содержат хук `created`, то&nbsp;будут вызваны оба.

  Хуки примесей вызываются в&nbsp;порядке их&nbsp;определения, до&nbsp;вызова собственных хуков компонента.

- **Пример:**

  ``` js
  var mixin = {
    created: function () { console.log(1) }
  }
  var vm = new Vue({
    created: function () { console.log(2) },
    mixins: [mixin]
  })
  // -> 1
  // -> 2
  ```

- **См. также:** [Примеси](../guide/mixins.html)

### name

- **Тип:** `string`

- **Ограничение:** учитывается только при определении компонента.

- **Подробности:**

  Название компонента. Позволяет компоненту рекурсивно вызывать самого себя в&nbsp;шаблоне. Обратите внимание что когда компонент регистрируется глобально посредством `Vue.component()`, глобальный&nbsp;ID автоматически устанавливается равным его имени.

  Кроме того, компоненты с&nbsp;указанным `name` проще отлаживать из-за более понятных сообщений в&nbsp;консоли. В&nbsp;[Vue-devtools](https://github.com/vuejs/vue-devtools) все безымянные компоненты довольно неинформативно называются `<AnonymousComponent>`. Указание имён для компонентов значительно улучшает ситуацию.

### extends

- **Тип:** `Object | Function`

- **Подробности:**

  Позволяет декларативно наследоваться от&nbsp;другого компонента (который может быть либо простым объектом, либо конструктором), не&nbsp;используя `Vue.extend`. Главным образом предназначено для облегчения наследования между компонентами, определёнными в&nbsp;одном файле.

  Эта функциональность близка к&nbsp;`mixins`, с&nbsp;той разницей, что собственные опции компонента приоритетнее опций компонента, от&nbsp;которого происходит наследование.

- **Пример:**

  ``` js
  var CompA = { ... }

  // наследуем от CompA, не вызывая Vue.extend:
  var CompB = {
    extends: CompA,
    ...
  }
  ```

### delimiters

- **Тип:** `Array<string>`

- **По умолчанию:** `{% raw %}["{{", "}}"]{% endraw %}`

- **Подробности:**

  Разделители, выделяющие текст для интерполяции. **Доступно только в&nbsp;standalone-сборке.**

- **Пример:**

  ``` js
  new Vue({
    delimiters: ['${', '}']
  })

  // Разделители изменены на стиль строк-шаблонов в ES6
  ```

### functional

- **Тип:** `boolean`

- **Подробности:**

  Превращает компонент в&nbsp;функциональный, то&nbsp;есть не&nbsp;имеющий собственного состояния (`data`) и&nbsp;своего экземпляра (`this`). Такие компоненты по&nbsp;сути&nbsp;&mdash; просто `render`-функция, возвращающая узлы виртуального DOM. Это сильно ускоряет их&nbsp;рендеринг.

- **См. также:** [Функциональные компоненты](../guide/render-function.html#Функциональные-компоненты)

## Свойства экземпляра

### vm.$data

- **Тип:** `Object`

- **Подробности:**

  Объект с&nbsp;данными, над которым экземпляр Vue осуществляет наблюдение. Экземпляр проксирует сюда вызовы своих полей. (Например, `vm.a` будет указывать на&nbsp;`vm.$data.a`)

- **См. также:** [Опции — данные](#data)

### vm.$el

- **Тип:** `HTMLElement`

- **Только для чтения**

- **Подробности:**

  Корневой элемент DOM, управляемый экземпляром Vue.

### vm.$options

- **Тип:** `Object`

- **Только для чтения**

- **Подробности:**

  Опции, переданные в&nbsp;конструктор экземпляра Vue. Полезно, если вы&nbsp;хотите передавать туда собственные опции:

  ``` js
  new Vue({
    customOption: 'что-нибудь',
    created: function () {
      console.log(this.$options.customOption) // -> 'что-нибудь'
    }
  })
  ```

### vm.$parent

- **Тип:** `экземпляр Vue`

- **Только для чтения**

- **Подробности:**

  Экземпляр родителя, если он&nbsp;есть у&nbsp;текущего экземпляра.

### vm.$root

- **Тип:** `экземпляр Vue`

- **Только для чтения**

- **Подробности:**

  Корневой экземпляр Vue текущего дерева компонентов. Если у&nbsp;экземпляра нет родителя, в&nbsp;этом поле будет он&nbsp;сам.

### vm.$children

- **Тип:** `Array<экземпляр Vue>`

- **Только для чтения**

- **Подробности:**

  Компоненты-потомки экземпляра. **Обратите внимание, что порядок следования элементов в `$children` не&nbsp;гарантируется, и&nbsp;этот массив не&nbsp;реактивен.** Вместо того, чтобы использовать `$children` для связывания данных, попробуйте использовать обычный массив и&nbsp;директиву `v-for` для создания дочерних компонентов, и&nbsp;используйте этот массив как &laquo;источник истины&raquo;.

### vm.$slots

- **Тип:** `{ [name: string]: ?Array<VNode> }`

- **Только для чтения**

- **Подробности:**

  Используется для доступа к&nbsp;контенту, [распределяемому слотами](../guide/components.html#Распределение-контента-слотами). У&nbsp;каждого [именованного слота](../guide/components.html#Именованные-слоты) есть соответствующее значение (например, содержимое `slot="foo"` попадёт в&nbsp;`vm.$slots.foo`). Свойство `default` содержит узлы, не&nbsp;включённые в&nbsp;именованные слоты.

  Особенно полезно `vm.$slots` в&nbsp;компонентах с&nbsp;[render-функциями](../guide/render-function.html).

- **Пример:**

  ```html
  <blog-post>
    <h1 slot="header">
      Обо мне
    </h1>

    <p>Этот контент попадёт в vm.$slots.default, потому что он не в именованном слоте.</p>

    <p slot="footer">
      Copyright 2016 Evan You
    </p>

    <p>Этот контент тоже попадёт в vm.$slots.default.</p>.
  </blog-post>
  ```

  ```js
  Vue.component('blog-post', {
    render: function (createElement) {
      var header = this.$slots.header
      var body   = this.$slots.default
      var footer = this.$slots.footer
      return createElement('div', [
        createElement('header', header),
        createElement('main', body),
        createElement('footer', footer)
      ])
    }
  })
  ```

  - [Компонент `<slot>`](#slot-1)
  - [Распределение контента слотами](../guide/components.html#Распределение-контента-слотами)
  - [Render-функции — слоты](../guide/render-function.html#Слоты)

### vm.$scopedSlots

> Добавлено в&nbsp;версии 2.1.0

- **Тип:** `{ [name: string]: props => VNode | Array<VNode> }`

- **Только для чтения**

- **Подробности:**

  Используется для доступа к&nbsp;[слотам с&nbsp;ограниченной областью видимости](../guide/components.html#Слоты-с-ограниченной-областью-видимости). Для каждого слота, включая и&nbsp;слот `default`, объект содержащий соответствующую функцию, что возвращает VNode.

  Использование `vm.$scopedSlots` наиболее полезно при написании компонентов с&nbsp;использованием [render-функций](../guide/render-function.html).

- **См. также:**
  - [`<slot>` компонент](#slot-1)
  - [Слоты с ограниченной областью видимости](../guide/components.html#Слоты-с-ограниченной-областью-видимости)
  - [Render-функции — слоты](../guide/render-function.html#Слоты)


### vm.$refs

- **Тип:** `Object`

- **Только для чтения**

- **Подробности:**

  Объект, с&nbsp;дочерними компонентами, имеющими параметр `ref`.

- **См. также:**
  - [Ссылки на компоненты-потомки](../guide/components.html#Ссылки-на-компоненты-потомки)
  - [ref](#ref)

### vm.$isServer

- **Тип:** `boolean`

- **Только для чтения**

- **Подробности:**

  Запущен&nbsp;ли данный экземпляр Vue на&nbsp;сервере.

- **См. также:** [SSR. Рендеринг на&nbsp;стороне сервера](../guide/ssr.html)

## Методы экземпляра — данные

<h3 id="vm-watch">vm.$watch( expOrFn, callback, [options] )</h3>

- **Аргументы:**
  - `{string | Function} expOrFn`
  - `{Function} callback`
  - `{Object} [options]`
    - `{boolean} deep`
    - `{boolean} immediate`

- **Возвращает:** `{Function} unwatch`

- **Использование:**

  Запускает наблюдение за&nbsp;выражением или вычисляемой функцией на&nbsp;предмет изменений. В&nbsp;параметры коллбэка будут переданы новое и&nbsp;старое значения отслеживаемого объекта. Выражение может быть только простым путём до&nbsp;переменной с&nbsp;разделителями-точками. Для более сложных случаев используйте функцию.

  <p class="tip">Обратите внимание: когда изменяете (а&nbsp;не&nbsp;заменяете) объект или массив, старое и&nbsp;новое значения при вызове коллбэка будут совпадать, так как они ссылаются на&nbsp;один и&nbsp;тот&nbsp;же объект или массив. Vue не&nbsp;сохраняет копии объекта на&nbsp;момент, предшествовавший изменениям.</p>

- **Пример:**

  ``` js
  // следим за переменной, указанной путём:
  vm.$watch('a.b.c', function (newVal, oldVal) {
    // переменная изменилась, сделайте что-нибудь
  })

  // следим за функцией:
  vm.$watch(
    function () {
      return this.a + this.b
    },
    function (newVal, oldVal) {
      // значение функции изменилось, сделайте что-нибудь
    }
  )
  ```

  `vm.$watch` возвращает функцию unwatch, которая останавливает слежение:

  ``` js
  var unwatch = vm.$watch('a', cb)
  // позднее, останавливаем слежение:
  unwatch()
  ```

- **Опция: deep**

  Чтобы слежение реагировало на&nbsp;изменения во&nbsp;вложенных объектах, передайте `deep: true` в&nbsp;объекте параметров. Обратите внимание, что для наблюдения за&nbsp;изменениями массивов этого не&nbsp;требуется.

  ``` js
  vm.$watch('someObject', callback, {
    deep: true
  })
  vm.someObject.nestedValue = 123
  // вызывается callback
  ```

- **Опция: immediate**

  Если передано `immediate: true`, коллбэк будет вызван сразу&nbsp;же после начала наблюдения с&nbsp;текущим значением выражения:

  ``` js
  vm.$watch('a', callback, {
    immediate: true
  })
  // callback вызывается сразу, с текущим значением `a`
  ```

<h3 id="vm-set">vm.$set( object, key, value )</h3>

- **Аргументы:**
  - `{Object} object`
  - `{string} key`
  - `{any} value`

- **Возвращает:** установленное значение.

- **Использование:**

  **Псевдоним** глобального метода `Vue.set`.

- **См. также:** [Vue.set](#Vue-set)

<h3 id="vm-delete">vm.$delete( object, key )</h3>

- **Аргументы:**
  - `{Object} object`
  - `{string} key`

- **Использование:**

  **Псевдоним** глобального метода `Vue.delete`.

- **См. также:** [Vue.delete](#Vue-delete)

## Методы экземпляра — события

<h3 id="vm-on">vm.$on( event, callback )</h3>

- **Аргументы:**
  - `{string} event`
  - `{Function} callback`

- **Использование:**

  Создаёт подписку на&nbsp;пользовательское событие текущего&nbsp;vm. Такое событие можно породить функцией `vm.$emit`. Коллбэк получит все дополнительные аргументы, переданные этому методу.

- **Пример:**

  ``` js
  vm.$on('test', function (msg) {
    console.log(msg)
  })
  vm.$emit('test', 'привет')
  // -> "привет"
  ```

<h3 id="vm-once">vm.$once( event, callback )</h3>

- **Аргументы:**
  - `{string} event`
  - `{Function} callback`

- **Использование:**

  Создаёт подписку на&nbsp;пользовательское событие, но&nbsp;срабатывает только один раз. После первого&nbsp;же использования подписчик будет удалён.

<h3 id="vm-off">vm.$off( [event, callback] )</h3>

- **Аргументы:**
  - `{string} [event]`
  - `{Function} [callback]`

- **Использование:**

  Удаляет подписчика или подписчиков события.

  - Если функция вызвана без параметров, она удалит все подписки на&nbsp;события;

  - Если указан только тип события&nbsp;&mdash; удалит все подписки указанного события;

  - Если указан и&nbsp;тип события, и&nbsp;коллбэк&nbsp;&mdash; будет удалена именно эта подписка именно этого события.

<h3 id="vm-emit">vm.$emit( event, [...args] )</h3>

- **Аргументы:**
  - `{string} event`
  - `[...args]`

  Порождает событие в&nbsp;текущем экземпляре. Все дополнительно указанные параметры будут переданы в&nbsp;коллбэк подписки.

## Методы экземпляра — жизненный цикл

<h3 id="vm-mount">vm.$mount( [elementOrSelector] )</h3>

- **Аргументы:**
  - `{Element | string} [elementOrSelector]`
  - `{boolean} [hydrating]`

- **Возвращает:** `vm` — сам экземпляр

- **Использование:**

  Если при создании экземпляра Vue не&nbsp;была указана опция `el`, он&nbsp;окажется в&nbsp;&laquo;непримонтированном&raquo; (unmounted) состоянии, то&nbsp;есть без ассоциированного элемента DOM. Вызовите `vm.$mount()`, чтобы примонтировать такой экземпляр.

  Если параметр `elementOrSelector` не&nbsp;указан, шаблон будет отрендерен как элемент вне документа. Вы&nbsp;сможете затем вставить такой элемент нативным интерфейсом DOM.

  Метод возвращает сам экземпляр, чтобы вы&nbsp;могли вызывать дополнительные методы по&nbsp;цепочке.

- **Пример:**

  ``` js
  var MyComponent = Vue.extend({
    template: '<div>Привет!</div>'
  })

  // создаём и монтируем в #app (заменит #app):
  new MyComponent().$mount('#app')

  // другой вариант записи, делает то же самое:
  new MyComponent({ el: '#app' })

  // рендерим вне документа и вставляем в DOM позднее:
  var component = new MyComponent().$mount()
  document.getElementById('app').appendChild(component.$el)
  ```

- **См. также:**
  - [Диаграмма жизненного цикла](../guide/instance.html#Диаграмма-жизненного-цикла)
  - [SSR. Рендеринг на стороне сервера](../guide/ssr.html)

<h3 id="vm-forceUpdate">vm.$forceUpdate()</h3>

- **Использование:**

  Заставляет экземпляр Vue произвести перерендеринг. Обратите внимание, что этот метод затронет не&nbsp;все дочерние компоненты, а&nbsp;только сам экземпляр и&nbsp;дочерние компоненты с&nbsp;контентными слотами.

<h3 id="vm-nextTick">vm.$nextTick( [callback] )</h3>

- **Аргументы:**
  - `{Function} [callback]`

- **Использование:**

  Выполняет функцию `callback` при следующем цикле обновления DOM. Вызывайте сразу после изменения данных, чтобы работать с&nbsp;обновлённым DOM. Функция делает то&nbsp;же самое, что и&nbsp;глобальный `Vue.nextTick`, но&nbsp;кроме того связывает `this` с&nbsp;текущим экземпляром в&nbsp;коллбэке.

  > Добавлено в&nbsp;версии 2.1.0: возвращает `Promise`, если окружение их&nbsp;поддерживает и&nbsp;коллбэк не&nbsp;указан.

- **Пример:**

  ``` js
  new Vue({
    // ...
    methods: {
      // ...
      example: function () {
        // меняем данные:
        this.message = 'changed'
        // DOM ещё не обновлён
        this.$nextTick(function () {
          // теперь DOM обновлён
          // `this` указывает на текущий экземпляр
          this.doSomethingElse()
        })
      }
    }
  })
  ```

- **См. также:**
  - [Vue.nextTick](#Vue-nextTick)
  - [Очередь асинхронных обновлений](../guide/reactivity.html#Асинхронная-очередь-обновлений)

<h3 id="vm-destroy">vm.$destroy()</h3>

- **Использование:**

  Полностью уничтожает&nbsp;vm. Очищает связи с&nbsp;другими существующими&nbsp;vm, отвязывает директивы, отменяет все подписки на&nbsp;события.

  Вызывает хуки `beforeDestroy` и&nbsp;`destroyed`.

  <p class="tip">Как правило, вам не&nbsp;придётся вызывать этот метод самим. Лучше контролировать жизненный цикл дочерних компонентов в&nbsp;data-driven стиле директивами `v-if` и&nbsp;`v-for`.</p>

- **См. также:** [Диаграмма жизненного цикла](../guide/instance.html#Диаграмма-жизненного-цикла)

## Директивы

### v-text

- **Принимает:** `string`

- **Подробности:**

  Управляет текстовым содержимым элемента (`textContent`). Если вам нужно управлять только частью содержимого тега, используйте интерполяцию `{% raw %}{{ Mustache }}{% endraw %}`.

- **Пример:**

  ```html
  <span v-text="msg"></span>
  <!-- то же, что -->
  <span>{{msg}}</span>
  ```

- **См. также:** [Синтаксис шаблонов — интерполяции](../guide/syntax.html#Текст)

### v-html

- **Принимает:** `string`

- **Подробности:**

  Управляет HTML-содержимым элемента (`innerHTML`). **Обратите внимание, что содержимое вставляется как обычный HTML&nbsp;&mdash; то&nbsp;есть не&nbsp;компилируется как шаблон Vue**. Не&nbsp;стоит организовывать вложенные шаблоны с&nbsp;помощью `v-html`, попробуйте лучше применить компоненты.

  <p class="tip">Динамический рендеринг произвольного HTML-кода на&nbsp;сайте&nbsp;&mdash; это очень опасная практика, легко приводящая к&nbsp;[XSS-уязвимостям](https://en.wikipedia.org/wiki/Cross-site_scripting). Передавайте в&nbsp;`v-html` только содержимое, которому можно доверять, и&nbsp;**никогда**&nbsp;&mdash; необработанный пользовательский ввод.</p>

- **Пример:**

  ```html
  <div v-html="html"></div>
  ```
- **См. также:** [Синтаксис шаблонов — интерполяции](../guide/syntax.html#Сырой-HTML)

### v-show

- **Принимает:** `any`

- **Использование:**

  Переключает CSS-свойство `display` элемента, в&nbsp;зависимости от&nbsp;того, истинно&nbsp;ли указанное выражение.

  При изменении состояния этой директивы вызываются анимации, заданные в&nbsp;transition.

- **См. также:** [Условный рендеринг — v-show](../guide/conditional.html#v-show)


### v-if

- **Принимает:** `any`

- **Использование:**

  Осуществляет рендеринг элемента, только если передаваемое выражение истинно. При изменении значения выражения на&nbsp;противоположное, элемент и&nbsp;содержащиеся в&nbsp;нём компоненты и&nbsp;директивы уничтожаются/пересоздаются. Если элемент&nbsp;&mdash; `<template>`, вместо него будет отрендерено его содержимое.

  Эта директива также запускает анимационные переходы при изменении условия.

  <p class="tip">При совместном использовании `v-if` и&nbsp;`v-for`, `v-for` имеет более высокий приоритет. Подробности на&nbsp;странице <a href="../guide/list.html#v-for-и-v-if">рендеринга списков</a>.</p>

- **См. также:** [Условный рендеринг — v-if](../guide/conditional.html#v-if)


### v-else

- **Не принимает какое-либо выражение**

- **Ограничение:** предыдущий элемент должен иметь директиву `v-if` или `v-else-if`.

- **Использование:**

  Определяет &laquo;блок else&raquo; для `v-if` или цепочки `v-if`/`v-else-if`.

  ```html
  <div v-if="Math.random() > 0.5">
    Сейчас меня видно
  </div>
  <div v-else>
    А сейчас — нет
  </div>
  ```

- **См. также:**
  - [Условный рендеринг — v-else](../guide/conditional.html#v-else)

### v-else-if

> Добавлено в&nbsp;версии 2.1.0

- **Ожидает:** `any`

- **Ограничение:** предшествующий элемент должен иметь `v-if` или `v-else-if`.

- **Использование:**

  Обозначает &laquo;блок else&nbsp;if&raquo; для `v-if`. Можно объединять в&nbsp;цепочки.

  ```html
  <div v-if="type === 'A'">
    A
  </div>
  <div v-else-if="type === 'B'">
    B
  </div>
  <div v-else-if="type === 'C'">
    C
  </div>
  <div v-else>
    Не A/B/C
  </div>
  ```

- **См. также:** [Условный рендеринг — v-else-if](../guide/conditional.html#v-else-if)

### v-for

- **Принимает:** `Array | Object | number | string`

- **Использование:**

  Многократно рендерит элемент или блок шаблона, основываясь на&nbsp;переданных данных. Значение директивы должно следовать синтаксису `alias in expression`&nbsp;&mdash; в&nbsp;`alias` будет элемент текущей итерации:

  ``` html
  <div v-for="item in items">
    {{ item.text }}
  </div>
  ```

   Кроме того, вы&nbsp;можете указать название для индекса (или ключа, если вы&nbsp;работаете с&nbsp;объектом):

  ``` html
  <div v-for="(item, index) in items"></div>
  <div v-for="(val, key) in object"></div>
  <div v-for="(val, key, index) in object"></div>
  ```

  По&nbsp;умолчанию `v-for` будет пытаться обновить элементы &laquo;на&nbsp;месте&raquo;, не&nbsp;перемещая&nbsp;их. Если вам нужно, чтобы элементы перемещались, сохраняя явную упорядоченность, укажите атрибут `key`:

  ``` html
  <div v-for="item in items" :key="item.id">
    {{ item.text }}
  </div>
  ```

  <p class="tip">При совместном использовании `v-if` и&nbsp;`v-for`, `v-for` имеет более высокий приоритет. Подробности на&nbsp;странице <a href="../guide/list.html#v-for-и-v-if">рендеринга списков</a>.</p>

  Использование `v-for` подробно описано в&nbsp;секции руководства по&nbsp;ссылке ниже.

- **См. также:**
  - [Рендеринг списков](../guide/list.html)
  - [key](../guide/list.html#key)

### v-on

- **Сокращение:** `@`

- **Принимает:** `Function | Inline-выражение`

- **Параметр:** `event (обязательный)`

- **Модификаторы:**
  - `.stop`&nbsp;&mdash; вызовет `event.stopPropagation()`.
  - `.prevent`&nbsp;&mdash; вызовет `event.preventDefault()`.
  - `.capture`&nbsp;&mdash; добавит подписку в&nbsp;режиме capture.
  - `.self`&nbsp;&mdash; вызовет обработчик только если событие возникло непосредственно на&nbsp;этом элементе.
  - `.{keyCode | keyAlias}`&nbsp;&mdash; вызывает обработчик только при нажатии определённой клавиши.
  - `.native`&nbsp;&mdash; подписаться на&nbsp;нативное событие на&nbsp;корневом элементе компонента.
  - `.once`&nbsp;&mdash; вызовет обработчик не&nbsp;больше одного раза.

- **Использование:**

  Прикрепляет к&nbsp;элементу подписчик события. Тип события указывается в&nbsp;параметре. Выражение может быть именем метода, inline-выражением или вовсе отсутствовать, если указан один или несколько модификаторов.

  У&nbsp;обычного элемента можно подписаться только **на&nbsp;нативные события DOM**. У&nbsp;элемента компонента можно также подписаться **на&nbsp;пользовательские события**, вызываемые этим дочерним компонентом.

  При работе с&nbsp;нативными событиями DOM, метод получает нативное событие единственным аргументом. В&nbsp;inline-выражениях, можно получить к&nbsp;нему доступ с&nbsp;помощью `$event`: `v-on:click="handle('ok', $event)"`.

- **Пример:**

  ```html
  <!-- обработчик метода -->
  <button v-on:click="doThis"></button>

  <!-- inline-выражение -->
  <button v-on:click="doThat('hello', $event)"></button>

  <!-- сокращённая запись -->
  <button @click="doThis"></button>

  <!-- модификатор stop propagation -->
  <button @click.stop="doThis"></button>

  <!-- модификатор prevent default -->
  <button @click.prevent="doThis"></button>

  <!-- модификатор prevent default без дополнительных действий -->
  <form @submit.prevent></form>

  <!-- цепочка из модификаторов -->
  <button @click.stop.prevent="doThis"></button>

  <!-- модификатор клавиши keyAlias -->
  <input @keyup.enter="onEnter">

  <!-- модификатор клавиши keyCode -->
  <input @keyup.13="onEnter">

  <!-- обработчик метода будет вызван не больше одного раза -->
  <button v-on:click.once="doThis"></button>
  ```

  Подписка на&nbsp;пользовательское событие в&nbsp;дочернем элементе (обработчик вызывается, когда дочерний элемент вызывает &laquo;my-event&raquo;):

  ```html
  <my-component @my-event="handleThis"></my-component>

  <!-- inline-выражение -->
  <my-component @my-event="handleThis(123, $event)"></my-component>

  <!-- подписываемся на нативное событие в компоненте -->
  <my-component @click.native="onClick"></my-component>
  ```

- **См. также:**
  - [Обработка событий](../guide/events.html)
  - [Компоненты — пользовательские события](../guide/components.html#Пользовательские-события)

### v-bind

- **Сокращение:** `:`

- **Принимает:** `any (если указан параметр) | Object (если параметр не указан)`

- **Параметр:** `attrOrProp (опционально)`

- **Модификаторы:**
  - `.prop` &mdash; используется для связывания в&nbsp;качестве DOM-свойства, а&nbsp;не&nbsp;атрибута ([в&nbsp;чём разница?](http://stackoverflow.com/questions/6003819/properties-and-attributes-in-html#answer-6004028)).
  - `.camel` &mdash; преобразует имена атрибутов в&nbsp;kebab-case в&nbsp;camelCase (поддержка добавлена в&nbsp;версии 2.1.0).

- **Использование:**

  Динамически связывает атрибуты тега или входной параметр компонента с&nbsp;выражением.

  При использовании с&nbsp;атрибутами `class` и&nbsp;`style` поддерживает массивы и&nbsp;объекты в&nbsp;качестве значений. Подробнее это описано в&nbsp;соответствующем руководстве по&nbsp;ссылке ниже.

  Для правильного связывания входного параметра компонента, тот должен быть корректно определён в&nbsp;дочернем компоненте.

  Если аргумент не&nbsp;указан, связанное значение может быть содержащим пары имя-значение. Обратите внимание, что в&nbsp;этом случае атрибуты `class` и&nbsp;`style` не&nbsp;поддерживают массивы и&nbsp;объекты.

- **Пример:**

  ```html
  <!-- связывание атрибута -->
  <img v-bind:src="imageSrc">

  <!-- сокращение -->
  <img :src="imageSrc">

  <!-- поддержка конкатенации строк -->
  <img :src="'/path/to/images/' + fileName">

  <!-- связывание CSS-класса -->
  <div :class="{ red: isRed }"></div>
  <div :class="[classA, classB]"></div>
  <div :class="[classA, { classB: isB, classC: isC }]">

  <!-- связывание локального стиля -->
  <div :style="{ fontSize: size + 'px' }"></div>
  <div :style="[styleObjectA, styleObjectB]"></div>

  <!-- связывание с объектом, содержащим атрибуты -->
  <div v-bind="{ id: someProp, 'other-attr': otherProp }"></div>

  <!-- связывание с атрибутами DOM при указании модификатора -->
  <div v-bind:text-content.prop="text"></div>

  <!-- связывание входного параметра. "prop" должен быть определён в my-component. -->
  <my-component :prop="someThing"></my-component>

  <!-- XLink -->
  <svg><a :xlink:special="foo"></a></svg>
  ```

  Модификатор `.camel` позволяет перевод имени атрибута `v-bind` в&nbsp;camelCase при использовании DOM-шаблонов, например для атрибута `viewBox` SVG:

  ``` html
  <svg :view-box.camel="viewBox"></svg>
  ```

  В&nbsp;использовании `.camel` нет необходимости, если вы&nbsp;пользуетесь строковыми шаблонами или `vue-loader`/`vueify`.

- **См. также:**
  - [Работа с классами и стилями](../guide/class-and-style.html)
  - [Компоненты — входные параметры компонентов](../guide/components.html#Входные-параметры)


### v-model

- **Принимает:** разное, в&nbsp;зависимости от&nbsp;типа форм или выходных данных компонентов

- **Используется только с:**
  - `<input>`
  - `<select>`
  - `<textarea>`
  - компонентами

- **Модификаторы:**
  - [`.lazy`](../guide/forms.html#lazy) — подписаться на&nbsp;события `change`, а&nbsp;не&nbsp;`input`
  - [`.number`](../guide/forms.html#number) — приводить введённую строку к&nbsp;числу
  - [`.trim`](../guild/forms.html#trim) — удалять пробелы в&nbsp;начале и&nbsp;в&nbsp;конце введённой строки

- **Использование:**

  Двусторонним образом связывает элемент ввода данных или компонент с&nbsp;переменной. Директива подробно описана в&nbsp;руководстве по&nbsp;ссылке ниже.

- **См. также:**
  - [Работа с формами](../guide/forms.html)
  - [Компоненты — поля ввода форм с использованием пользовательских событий](../guide/components.html#Поля-ввода-форм-с-использованием-пользовательских-событий)

### v-pre

- **Не принимает какое-либо выражение**

- **Использование:**

  Пропустить компиляцию для этого элемента и&nbsp;всех его потомков. Вы&nbsp;можете использовать это для отображения необработанных тегов `{% raw %}{{}}{% endraw %}`. Кроме того, пропуск большого количества элементов может ускорить компиляцию.

- **Пример:**

  ```html
  <span v-pre>{{ эта часть не будет скомпилирована }}</span>
   ```

### v-cloak

- **Не принимает какое-либо выражение**

- **Использование:**

  Эта директива останется на&nbsp;элементе до&nbsp;тех пор, пока связанный с&nbsp;ним экземпляр Vue не&nbsp;закончит компиляцию. В&nbsp;сочетании с&nbsp;CSS-правилом `[v-cloak] { display: none }` этой директивой можно скрывать нескомпилированные шаблоны до&nbsp;тех пор, пока экземпляр Vue не&nbsp;будет готов.

- **Пример:**

  ```css
  [v-cloak] {
    display: none;
  }
  ```

  ```html
  <div v-cloak>
    {{ message }}
  </div>
  ```

  Элемент `<div>` не&nbsp;появится, пока компиляция не&nbsp;закончится.

### v-once

- **Не принимает какое-либо выражение**

- **Использование:**

  **Однократно** рендерит элемент или компонент. При повторном рендеринге&nbsp;он, а&nbsp;также все его потомки, рассматриваются как статический контент и&nbsp;пропускаются. Это поможет увеличить производительность обновлений.

  ```html
  <!-- одиночный элемент -->
  <span v-once>Это никогда не изменится: {{msg}}</span>

  <!-- элемент с потомком -->
  <div v-once>
    <h1>comment</h1>
    <p>{{msg}}</p>
  </div>

  <!-- компонент -->
  <my-component v-once :comment="msg"></my-component>

  <!-- директива v-for -->
  <ul>
    <li v-for="i in list" v-once>{{i}}</li>
  </ul>
  ```

- **См. также:**
  - [Синтаксис шаблонов — интерполяции](../guide/syntax.html#Текст)
  - [Компоненты — дешёвые статические компоненты с v-once](../guide/components.html#“Дешёвые”-статические-компоненты-с-использованием-v-once)

## Специальные атрибуты

### key

- **Принимает:** `string`

  Атрибут `key` помогает алгоритму работы с&nbsp;виртуальным DOM определить, какие ноды соответствует какой строке данных. Если этот атрибут не&nbsp;указан, Vue использует алгоритм, минимизирующий перемещение элементов и&nbsp;старается обновить и&nbsp;повторно использовать как можно больше элементов правильного типа &laquo;на&nbsp;местах&raquo;. А&nbsp;если ключ указан, Vue изменяет порядок следования элементов, основываясь на&nbsp;изменении порядка ключей. Элементы, соответствующие ключам, которых больше нет, Vue всегда уничтожает.

  Потомки одного и&nbsp;того&nbsp;же общего родителя должны иметь **уникальные ключи**. Повторяющиеся ключи приведут к&nbsp;ошибкам при рендеринге.

  Как правило, используется в&nbsp;связке с&nbsp;`v-for`:

  ``` html
  <ul>
    <li v-for="item in items" :key="item.id">...</li>
  </ul>
  ```

  Можно также применить эту директиву, чтобы элемент всегда заменялся на&nbsp;новый, а&nbsp;не&nbsp;переиспользовался. Это может помочь, если вы&nbsp;хотите:

  - Быть уверенным, что все хуки жизненного цикла компонента будут вызваны
  - Запускать анимации (например, установленные в&nbsp;transition)

  Например:

  ``` html
  <transition>
    <span :key="text">{{ text }}</span>
  </transition>
  ```

  При изменении `text`, `<span>` всегда будет заменяться целиком, что спровоцирует вызов анимации.

### ref

- **Принимает:** `string`

  Название элемента или компонента для регистрации ссылки на&nbsp;него. В&nbsp;объекте `$refs` появится поле с&nbsp;названием из&nbsp;этого атрибута и&nbsp;значением: элементом DOM, если атрибут стоял на&nbsp;простом теге или экземпляром компонента, если атрибут стоял на&nbsp;пользовательском компоненте:

  ``` html
  <!-- vm.$refs.p будет DOM-элементом -->

  <p ref="p">hello</p>

  <!-- vm.$refs.child будет указывать на экземпляр ChildComp -->
  <child-comp ref="child"></child-comp>
  ```

  При использовании на&nbsp;элементах/компонентах с&nbsp;`v-for`, регистрируется массив ссылок на&nbsp;элементы DOM или экземпляры компонентов.

  Важное замечание о&nbsp;времени регистрации ссылок: поскольку ссылки создаются `render`-функцией, вы&nbsp;не&nbsp;cможете использовать их&nbsp;при первичном рендеринге&nbsp;&mdash; на&nbsp;тот момент они ещё не&nbsp;существуют! Кроме того, объект `$refs` не&nbsp;является реактивным, поэтому не&nbsp;стоит пытаться использовать его в&nbsp;шаблонах для связывания данных.

- **См. также:** [Ссылки на компоненты-потомки](../guide/components.html#Ссылки-на-компоненты-потомки)

### slot

- **Принимает:** `string`

  Используется в&nbsp;содержимом дочерних компонентов для указания того, к&nbsp;какому из&nbsp;именованных слотов принадлежит отмеченный контент.

  Подробнее в&nbsp;руководстве по&nbsp;ссылке ниже.

- **См. также:** [Именованные слоты](../guide/components.html#Именованные-слоты)

## Встроенные компоненты

### component

- **Входные параметры:**
  - `is` — string | ComponentDefinition | ComponentConstructor
  - `inline-template` — boolean

- **Использование:**

  &laquo;Метакомпонент&raquo; для рендеринга динамических компонентов. Настоящий компонент для рендеринга определяется параметром&nbsp;`is`:

  ```html
  <!-- динамический компонент, контролируемый -->
  <!-- свойством vm `componentId`-->
  <component :is="componentId"></component>

  <!-- может также рендерить зарегистрированный или переданный параметром компонент -->
  <component :is="$options.components.child"></component>
  ```

- **См. также:** [Динамическое переключение компонентов](../guide/components.html#Динамическое-переключение-компонентов)

### transition

- **Входные параметры:**
  - `name` — string, используется для автоматической генерации имён CSS-классов для анимаций. Например, `name: 'fade'` автоматически раскроется в&nbsp;`.fade-enter`, `.fade-enter-active` и&nbsp;т.д. Значение по&nbsp;умолчанию&nbsp;&mdash;&nbsp;`"v"`.
  - `appear` — boolean, вызывать&nbsp;ли анимацию при первом рендеринге. По&nbsp;умолчанию `false`.
  - `css` — boolean, применять&nbsp;ли CSS-классы. По&nbsp;умолчанию `true`. Если установить в&nbsp;`false`, будут вызываться только обработчики JavaScript, зарегистрированные для событий компонента.
  - `type` — string, указывает тип событий, с&nbsp;помощью которых определяется момент завершения анимации. Доступные значения: `"transition"` и&nbsp;`"animation"`. По&nbsp;умолчанию автоматически выбирается тип, задающий наибольшую продолжительность.
  - `mode` — string, управляет порядком анимаций исчезновения и&nbsp;появления элементов. Доступные режимы `"out-in"` (сначала старый элемент исчезает, потом новый появляется) и&nbsp;`"in-out"` (сначала новый элемент появляется, потом исчезает старый). По&nbsp;умолчанию исчезновение и&nbsp;появление происходят одновременно.
  - `enter-class` — string
  - `leave-class` — string
  - `appear-class` — string
  - `enter-to-class` — string
  - `leave-to-class` — string
  - `appear-to-class` — string
  - `enter-active-class` — string
  - `leave-active-class` — string
  - `appear-active-class` — string

- **События:**
  - `before-enter`
  - `before-leave`
  - `before-appear`
  - `enter`
  - `leave`
  - `appear`
  - `after-enter`
  - `after-leave`
  - `after-appear`
  - `enter-cancelled`
  - `leave-cancelled` (только для `v-show`)
  - `appear-cancelled`

- **Использование:**

  Указывает анимацию перехода для **одного** элемента или компонента. `<transition>` не&nbsp;порождает дополнительного элемента DOM при рендеринге, и&nbsp;не&nbsp;отображается в&nbsp;иерархии компонентов в&nbsp;инспекторе. Этот компонент просто применяет поведение перехода к&nbsp;своему содержимому.

  ```html
  <!-- простой элемент -->
  <transition>
    <div v-if="ok">переключаемое содержимое</div>
  </transition>

  <!-- динамический компонент -->
  <transition name="fade" mode="out-in" appear>
    <component :is="view"></component>
  </transition>

  <!-- хук на событие -->
  <div id="transition-demo">
    <transition @after-enter="transitionComplete">
      <div v-show="ok">переключаемое содержимое</div>
    </transition>
  </div>
  ```

  ``` js
  new Vue({
    ...
    methods: {
      transitionComplete: function (el) {
        // сделайте что-нибудь с переданным элементом DOM ...
      }
    }
    ...
  }).$mount('#transition-demo')
  ```

- **См. также:** [Анимационные эффекты переходов: появление, исчезновение и списки](../guide/transitions.html)

### transition-group

- **Входные параметры:**
  - `tag` — string, по&nbsp;умолчанию используется `span`.
  - `move-class` — переопределяет CSS-класс, применяемый во&nbsp;время анимации перемещения.
  - те&nbsp;же атрибуты, что и&nbsp;у&nbsp;`<transition>` кроме `mode`.

- **События:**
  - те же, что и&nbsp;у&nbsp;`<transition>`.

- **Использование:**

  Указывает анимацию перехода для **нескольких** элементов или компонентов. `<transition-group>` превращается в&nbsp;реальный элемент DOM. По&nbsp;умолчанию для этого используется тег `<span>`, но&nbsp;можно указать любой другой в&nbsp;параметре `tag`.

  Обратите внимание, что каждый потомок `<transition-group>` должен иметь **уникальное значение key**, чтобы анимации работали корректно.

  Анимации перехода реализованы с&nbsp;помощью CSS-трансформаций. Когда позиция потомка изменилась после обновления, ему будет добавлен CSS-класс (автоматически сгенерированный из&nbsp;атрибута `name`, или&nbsp;же явно указанный в&nbsp;атрибуте `move-class`). Если после применения этого класса свойство `transform` можно будет анимировать, элемент будет с&nbsp;плавным переходом переведён туда, где он&nbsp;должен быть с&nbsp;помощью [техники FLIP](https://aerotwist.com/blog/flip-your-animations/).

  ```html
  <transition-group tag="ul" name="slide">
    <li v-for="item in items" :key="item.id">
      {{ item.text }}
    </li>
  </transition-group>
  ```

- **См. также:** [Анимационные эффекты переходов: появление, исчезновение и списки](../guide/transitions.html)

### keep-alive

- **Props:**
  - `include` — строка или регулярное выражение. Только соответствующие компоненты будут кешироваться.
  - `exclude` — строка или регулярное выражение. Все соответствующие компоненты не&nbsp;будут кешироваться.

- **Использование:**

  Оберните динамические компоненты тегом `<keep-alive>`, чтобы кешировать экземпляры интерактивных компонентов вместо того, чтобы их&nbsp;уничтожать. Так&nbsp;же, как и&nbsp;`<transition>`, `<keep-alive>` &mdash; абстрактный компонент: при рендеринге он&nbsp;не&nbsp;превращается в&nbsp;элемент DOM, и&nbsp;не&nbsp;показывается в&nbsp;цепочке родителей компонента.

  Когда компонент, расположенный внутри `<keep-alive>` показывается или скрывается, вызываются его хуки жизненного цикла `activated` или `deactivated` соответственно.

  В&nbsp;основном используется для сохранения состояния компонента, чтобы избежать повторного рендеринга.

  ```html
  <!-- базовый вариант -->
  <keep-alive>
    <component :is="view"></component>
  </keep-alive>

  <!-- несколько потомков -->
  <keep-alive>
    <comp-a v-if="a > 1"></comp-a>
    <comp-b v-else></comp-b>
  </keep-alive>

  <!-- использование вместе с <transition> -->
  <transition>
    <keep-alive>
      <component :is="view"></component>
    </keep-alive>
  </transition>
  ```

- **`include` и `exclude`**

  > Добавлено в&nbsp;версии 2.1.0

  Входные параметры `include` и&nbsp;`exclude` позволяют организовать условное кеширование компонентов. Оба параметра можно указать в&nbsp;виде строки со&nbsp;списком имён компонентов через запятую, или регулярным выражением:

  ``` html
  <!-- строка с именами через запятую -->
  <keep-alive include="a,b">
    <component :is="view"></component>
  </keep-alive>

  <!-- регулярное выражение (используйте v-bind) -->
  <keep-alive :include="/a|b/">
    <component :is="view"></component>
  </keep-alive>
  ```

  Проверяется сначала собственное значение опции `name` компонента, а&nbsp;в&nbsp;случае его недоступности&nbsp;&mdash; имя, указанное при локальной регистрации (ключ в&nbsp;опции `components` компонента-родителя). Анонимные компоненты таким образом проверить не&nbsp;получится.

  <p class="tip">`<keep-alive>` не&nbsp;работает с&nbsp;функциональными компонентами, так как у&nbsp;них отсутствуют экземпляры.</p>

- **См. также:** [Динамическое переключение компонентов — keep-alive](../guide/components.html#keep-alive)

### slot

- **Входные параметры:**
  - `name` — string, используется для именования слотов

- **Использование:**

  `<slot>` — элемент, чьё содержимое будет распределено в&nbsp;шаблон компонента. Сам элемент `<slot>` при рендеринге заменяется.

  Подробнее этот механизм описан в&nbsp;руководстве по&nbsp;ссылке ниже.

- **См. также:** [Расределение контента слотами](../guide/components.html#Распределение-контента-слотами)

## Интерфейс VNode

- Смотрите информацию об&nbsp;[объявлении классов VNode](https://github.com/vuejs/vue/blob/dev/src/core/vdom/vnode.js).

## Рендеринг на стороне сервера

- Смотрите [документацию пакета vue-server-renderer](https://github.com/vuejs/vue/tree/dev/packages/vue-server-renderer).
