---
type: api
---

## Глобальные параметры

`Vue.config` - это объект, содержащий глобальные параметры Vue. Перед загрузкой приложения можно изменить следующие свойства:

### silent

- **Тип:** `boolean`

- **По умолчанию:** `false`

- **Использование:**

  ``` js
  Vue.config.silent = true
  ```

  Отключает вывод логов и предупреждений Vue.

### optionMergeStrategies

- **Тип:** `{ [key: string]: Function }`

- **По умолчанию:** `{}`

- **Использование:**

  ``` js
  Vue.config.optionMergeStrategies._my_option = function (parent, child, vm) {
    return child + 1
  }

  const Profile = Vue.extend({
    _my_option: 1
  })

  // Profile.options._my_option = 2
  ```

  Меняет стратегию слияния опций на вашу собственную.

  Стратегия слияния получает значения опции родительского и дочернего элемента первым и вторым параметром соответственно.
  Третьим параметром передаётся контекст действующего инстанса Vue.

- **См. также:** [Пользовательские Стратегии Слияния Опций](../guide/mixins.html#Пользовательские-стратегии-слияния-опций)

### devtools

- **Тип:** `boolean`

- **По умолчанию:** `true` (`false` в production-сборках)

- **Использование:**

  ``` js
  // убедитесь, что устанавливаете это свойство синхронно сразу после загрузки Vue
  Vue.config.devtools = true
  ```

  Указывает, должен ли Vue позволять [vue-devtools](https://github.com/vuejs/vue-devtools) проводить инспекцию. Значение по умолчанию для development-окружения — `true`, для production-сборок — `false`. Установите `true`, чтобы vue-devtools работал и в production.

### errorHandler

- **Тип:** `Function`

- **По умолчанию:** Ошибка выбрасывается "на месте"

- **Использование:**

  ``` js
  Vue.config.errorHandler = function (err, vm) {
    // обработка ошибки
  }
  ```

  Устанавливает обработчик для ошибок, не пойманных во время рендеренга компонентов и в наблюдателях. Обработчик получит в параметрах ошибку и действующий инстанс Vue.

  > Сервис отслеживания ошибок [Sentry](https://sentry.io) предлагает [официальную интеграцию](https://sentry.io/for/vue/) с использованием этого свойства.

### ignoredElements

- **Тип:** `Array<string>`

- **По умолчанию:** `[]`

- **Использование:**

  ``` js
  Vue.config.ignoredElements = [
    'my-custom-web-component', 'another-web-component'
  ]
  ```
  
  Позволяет Vue игнорировать пользовательские компоненты, установленные за пределами Vue (например, используя Web Components APIs). Иначе возникнет предупреждение о 'Неизвестном пользовательском элементе', означающее, что вы забыли зарегистрировать глобальный компонент или допустили ошибку в написании имени компонента.

### keyCodes

- **Тип:** `{ [key: string]: number }`

- **По умолчанию:** `{}`

- **Использование:**

  ``` js
  Vue.config.keyCodes = {
    v: 86,
    f1: 112,
    mediaPlayPause: 179
  }
  ```

  Определяет один или несколько дополнительных алиасов для директивы v-on.

## Глобальный API

<h3 id="Vue-extend">Vue.extend( options )</h3>

- **Аргументы:**
  - `{Object} options`

- **Использование:**

  Создаёт "подкласс" базового конструктора Vue. Принимает параметром объект с опциями нового компонента.

  Внимание: у объекта, переданного в `Vue.extend()` свойство `data` должно быть функцией.

  ``` html
  <div id="mount-point"></div>
  ```

  ``` js
  // create constructor
  var Profile = Vue.extend({
    template: '<p>{{firstName}} {{lastName}}, также известный как {{alias}}</p>',
    data: function () {
      return {
        firstName: 'Уолтер',
        lastName: 'Уайт',
        alias: 'Гейзенберг'
      }
    }
  })
  // создаёт инстанс Profile и монтирует его к элементу DOM
  new Profile().$mount('#mount-point')
  ```

  Результатом будет:

  ``` html
  <p>Walter White aka Heisenberg</p>
  ```

- **См. также:** [Компоненты](../guide/components.html)

<h3 id="Vue-nextTick">Vue.nextTick( callback, [context] )</h3>

- **Аргументы:**
  - `{Function} callback`
  - `{Object} [context]`

- **Использование:**

  Выполняет функцию callback при следующем цикле обновления DOM. Вызывайте сразу после изменения данных, чтобы работать с обновлённым DOM.

  ``` js
  // modify data
  vm.msg = 'Привет'
  // DOM ещё не обновлён
  Vue.nextTick(function () {
    // теперь DOM обновлён
  })
  ```

- **См. также:** [Асинхронная Очередь Обновлений](../guide/reactivity.html#Асинхронная-очередь-обновлений)

<h3 id="Vue-set">Vue.set( object, key, value )</h3>

- **Аргументы:**
  - `{Object} object`
  - `{string} key`
  - `{any} value`

- **Возвращает:** установленное значение.

- **Использование:**

  Меняет значение поля. Если объект реактивный, поле тоже станет реактивным, а view обновится. Обычно нужен, потому что Vue не может среагировать на неявное добавление полей.

  **Обратите внимание что объект не может быть инстансом Vue или корневым объектом data инстанса Vue.**

- **См. также:** [Подробно о реактивности](../guide/reactivity.html)

<h3 id="Vue-delete">Vue.delete( object, key )</h3>

- **Аргументы:**
  - `{Object} object`
  - `{string} key`

- **Использование:**

  Удаляет поле. Если объект реактивный, view обновится. Обычно нужен, потому что Vue не может среагировать на неявное удаление полей (но вы вряд ли часто будете пользоваться этой функцией).

  **Обратите внимание что объект не может быть инстансом Vue или корневым объектом data инстанса Vue.**

- **См. также:** [Подробно о реактивности](../guide/reactivity.html)

<h3 id="Vue-directive">Vue.directive( id, [definition] )</h3>

- **Аргументы:**
  - `{string} id`
  - `{Function | Object} [definition]`

- **Использование:**

  Регистрирует новую глобальную директиву или возвращает уже зарегистрированную.

  ``` js
  // регистрируем директиву-объект:
  Vue.directive('my-directive', {
    bind: function () {},
    inserted: function () {},
    update: function () {},
    componentUpdated: function () {},
    unbind: function () {}
  })

  // региструем директиву в виде простой функции:
  Vue.directive('my-directive', function () {
    // Vue будет вызывать эту функцию как `bind` и `update`
  })

  // получаем определение директивы, если она зарегистрирована:
  var myDirective = Vue.directive('my-directive')
  ```

- **См. также:** [Пользовательские директивы](../guide/custom-directive.html)

<h3 id="Vue-filter">Vue.filter( id, [definition] )</h3>

- **Аргументы:**
  - `{string} id`
  - `{Function} [definition]`

- **Использование:**

  Регистрирует новый глобальный фильтр или возвращает уже зарегистрированный.

  ``` js
  // регистрируем фильтр:
  Vue.filter('my-filter', function (value) {
    // верните в функции результат обработки
  })

  // получаем фильтр, если он зарегистрирован:
  var myFilter = Vue.filter('my-filter')
  ```

<h3 id="Vue-component">Vue.component( id, [definition] )</h3>

- **Аргументы:**
  - `{string} id`
  - `{Function | Object} [definition]`

- **Использование:**

  Регистрирует новый глобальный компонент или возвращает уже зарегистрированный. Имя (`name`) компонента автоматически указывается равным переданному `id`.

  ``` js
  // регистрируем конструктор, полученный из Vue.extend:
  Vue.component('my-component', Vue.extend({ /* ... */ }))

  // регистрируем объект с опциями (Vue вызовет для этого объекта Vue.extend автоматически):
  Vue.component('my-component', { /* ... */ })

  // получаем зарегистрированный компонент (всегда вернёт конструктор):
  var MyComponent = Vue.component('my-component')
  ```

- **См. также:** [Компоненты](../guide/components.html)

<h3 id="Vue-use">Vue.use( plugin )</h3>

- **Аргументы:**
  - `{Object | Function} plugin`

- **Использование:**

  Устанавливает плагин Vue.js. Если плагин — объект, у него должен быть публичный метод `install`. Если плагин — функция, она будет воспринята как метод install. Этот метод будет выполнен с Vue в качестве аргумента.

  Сколько бы раз вы не выполняли этот метод с одним и тем же плагином, плагин будет установлен только однажды.

- **См. также:** [Плагины](../guide/plugins.html)

<h3 id="Vue-mixin">Vue.mixin( mixin )</h3>

- **Аргументы:**
  - `{Object} mixin`

- **Использование:**

  Применяет миксин ко всем созданным впоследствии инстансам Vue. Так авторы плагинов могут встроить желаемое поведение в компоненты. **Не рекомендуем использовать в коде приложений**.

- **См. также:** [Глобальные миксины](../guide/mixins.html#Глобальные-миксины)

<h3 id="Vue-compile">Vue.compile( template )</h3>

- **Аргументы:**
  - `{string} template`

- **Использование:**

  Компилирует строковой шаблон в render-функцию. **Доступен только в автономной сборке.**

  ``` js
  var res = Vue.compile('<div><span>{{ msg }}</span></div>')

  new Vue({
    data: {
      msg: 'hello'
    },
    render: res.render,
    staticRenderFns: res.staticRenderFns
  })
  ```

- **См. также:** [Render-функции](../guide/render-function.html)

## Опции — данные

### data

- **Тип:** `Object | Function`

- **Ограничение:** При создании компонента, может быть только типа `Function`.

- **Подробности:**

  Объект с данными инстанса Vue. Vue рекурсивно переводит его поля в геттеры/сеттеры, и он становится "реактивным". **Объект должен быть простым**: Vue проигнорирует свойства прототипа и нативные объекты, как например из API браузера. Прежде всего, рекомендуем чтобы данные были просто данными — не стоит передавать сюда объекты с собственным управлением внутренним состоянием.

  Добавлять реактивные свойства к корневому объекту данных после его инициализации нельзя. Поэтому определяйте корневые реактивные свойства до создания инстанса.

  После создания инстанса, объект с данными доступен в `vm.$data`. Кроме того, инстанс Vue проксирует обнаруженные в нём свойства, так что `vm.a` эквивалентно `vm.$data.a`.

  Свойства, названия которых начинается с `_` или `$` **не** проксируются из-за возможных конфликтов со внутренними свойствами и методами API Vue. Доступ к таким свойствам возможен только через `vm.$data._property`.

  Для определения **компонента** `data` должен быть функцией, возвращающей объект для инициализации, потому что из одного определения компонента может быть создано несколько инстансов. Если бы мы использовали для `data` простой объект, все созданные инстансы получили бы **ссылку на него**! А когда `data` — функция, при создании нового инстанса можно вызвать её и получить свежую копию данных для инициализации.

  Чтобы получить полную копию оригинального объекта, передайте `vm.$data` в `JSON.parse(JSON.stringify(...))`.

- **Пример:**

  ``` js
  var data = { a: 1 }

  // создаём инстанс напрямую:
  var vm = new Vue({
    data: data
  })
  vm.a // -> 1
  vm.$data === data // -> true

  // обязательно используйте функцию во Vue.extend():
  var Component = Vue.extend({
    data: function () {
      return { a: 1 }
    }
  })
  ```

  <p class="tip">Обратите внимание, что __вам не стоит использовать arrow-функции в параметре `data`__ (напр. `data: () => { return { a: this.myProp }}`). Поскольку arrow-функции связываются с родительским контекстом, `this` не будет указывать на инстанс Vue и `this.myProp` окажется неопределенным.</p>

- **См. также:** [Подробно о реактивности](../guide/reactivity.html)

### props

- **Тип:** `Array<string> | Object`

- **Подробности:**

  Список или хэш атрибутов, по которым разрешено получение данных от родительского компонента. Передайте простой массив названий или объект, задающий дополнительные параметры, например типы, правила валидации и значения по умолчанию.

- **Пример:**

  ``` js
  // простая форма записи:
  Vue.component('props-demo-simple', {
    props: ['size', 'myMessage']
  })

  // объект с указанием правил валидации:
  Vue.component('props-demo-advanced', {
    props: {
      // только проверка типа
      height: Number,
      // проверка типа и другие правила валидации
      age: {
        type: Number,
        default: 0,
        required: true,
        validator: function (value) {
          return value >= 0
        }
      }
    }
  })
  ```

- **См. также:** [Входные Параметры](../guide/components.html#Входные-параметры)

### propsData

- **Тип:** `{ [key: string]: any }`

- **Ограничение:** учитывается только при создании инстанса выражением `new`.

- **Подробности:**

  Параметры компонента при его создании. Обычно используется для тестирования.

- **Пример:**

  ``` js
  var Comp = Vue.extend({
    props: ['msg'],
    template: '<div>{{ msg }}</div>'
  })

  var vm = new Comp({
    propsData: {
      msg: 'привет'
    }
  })
  ```

### computed

- **Тип:** `{ [key: string]: Function | { get: Function, set: Function } }`

- **Подробности:**

  Вычисляемые свойства, которые будут подмешаны к инстансу Vue. В геттерах и сеттерах `this` будет указывать на инстанс Vue.

  <p class="tip">Обратите внимание, что __вам не стоит использовать arrow-функции при определении вычисляемых свойств__ (напр. `aDouble: () => this.a * 2`). Поскольку arrow-функции связываются с родительским контекстом, `this` не будет указывать на инстанс Vue, и `this.a` окажется неопределенным.</p>

  Вычисляемые свойства кэшируются и повторно вычисляются только при изменении реактивных зависимостей.

- **Пример:**

  ```js
  var vm = new Vue({
    data: { a: 1 },
    computed: {
      // если свойство только возвращает данные, достаточно простой функции:
      aDouble: function () {
        return this.a * 2
      },
      // свойство и возвращает, и получает данные:
      aPlus: {
        get: function () {
          return this.a + 1
        },
        set: function (v) {
          this.a = v - 1
        }
      }
    }
  })
  vm.aPlus   // -> 2
  vm.aPlus = 3
  vm.a       // -> 2
  vm.aDouble // -> 4
  ```

- **См. также:**
  - [Вычисляемые свойства](../guide/computed.html)

### methods

- **Тип:** `{ [key: string]: Function }`

- **Подробности:**

  Методы, которые будут подмешаны к инстансу Vue. Вы можете получить запустить эти методы прямо из инстанса VM, или использовать их в директивах. `this` методов указывает на инстанс Vue.

  <p class="tip">Обратите внимание, что __вам не стоит использовать arrow-функции при определении методов__ (напр. `plus: () => this.a++`). Поскольку arrow-функции связываются с родительским контекстом, `this` не будет указывать на инстанс Vue, и `this.a` окажется неопределенным.</p>

- **Пример:**

  ```js
  var vm = new Vue({
    data: { a: 1 },
    methods: {9
      plus: function () {
        this.a++
      }
    }
  })
  vm.plus()
  vm.a // 2
  ```

- **См. также:** [Методы и обработка событий](../guide/events.html)

### watch

- **Тип:** `{ [key: string]: string | Function | Object }`

- **Подробности:**

  Объект, ключи которого — выражения для наблюдения, а значения — коллбэки, вызываемые при их изменении. Значения также могут строками с именами методов, или объектами, содержащими дополнительные опции. Инстанс Vue вызовет `$watch()` соответствующий каждому ключа объекта при своём создании.

- **Пример:**

  ``` js
  var vm = new Vue({
    data: {
      a: 1,
      b: 2,
      c: 3
    },
    watch: {
      a: function (val, oldVal) {
        console.log('новое значение: %s, старое значение: %s', val, oldVal)
      },
      // строка с именем метода:
      b: 'someMethod',
      // глубокий (рекурсивный) наблюдатель:
      c: {
        handler: function (val, oldVal) { /* ... */ },
        deep: true
      }
    }
  })
  vm.a = 2 // -> new: 2, old: 1
  ```

  <p class="tip">Обратите внимание, что __вам не стоит использовать arrow-функции при определении наблюдателей__ (напр. `searchQuery: newValue => this.updateAutocomplete(newValue)`). Поскольку arrow-функции связываются с родительским контекстом, `this` не будет указывать на инстанс Vue, и `this.updateAutocomplete` окажется неопределенным.</p>

- **См. также:** [Методы инстанса - vm.$watch](#vm-watch)

## Опции — DOM

### el

- **Тип:** `string | HTMLElement`

- **Ограничение:** учитывается только при создании инстанса выражением `new`.

- **Подробности:**

  Указывает, на какой существующий DOM-элемент смонтировать инстанс Vue. Может быть строковым CSS-селектором или собственно объектом типа HTMLElement.

  После монтирования инстанса, переданный или найденный по CSS-селектору элемент будет доступен в `vm.$el`.

  Если эта опция указана при создании инстанса, компиляция начнётся сразу же. В остальных случаях, вызовите `vm.$mount()`, чтобы запустить компиляцию.

  <p class="tip">Указанный элемент служит только точкой монтирования. В отличии от Vue 1.x, он обязательно будет заменен DOM-ом, сгенерированным Vue. Поэтому не стоит монтировать в корневые элементы `<html>` или `<body>`.</p>

- **См. также:** [Диаграмма жизненного цикла](../guide/instance.html#Диаграмма-жизненного-цикла)

### template

- **Тип:** `string`

- **Подробности:**

  Строковый шаблон с разметкой для инстанса Vue. Этот шаблон **заменит** элемент в точке монтирования. Вся уже существующая разметка в точке монтирования будет проигнорирована, если в шаблоне нет слота распределения контента.

  Если строка начинается с `#`, она будет использована как querySelector, а в качестве строкового шаблона будет использован innerHTML элемента с указанным id. Так вы сможете включать шаблоны, из тегов вроде `<script type="x-template">`.

  <p class="tip">Чтобы оставаться в безопасности, используйте только те шаблоны Vue, которым можете доверять. Никогда не используйте в качестве шаблона данные, вводимые пользователем.</p>

- **См. также:**
  - [Диаграмма жизненного цикла](../guide/instance.html#Диаграмма-жизненного-цикла)
  - [Распределение контента через слоты](../guide/components.html#Дистрибьюция-контента-через-слоты)

### render

  - **Тип:** `Function` 

  - **Подробности:**

    Альтернатива строковым шаблонам, позволяющая задействовать все алгоритмические возможности JavaScript. Render-функция получает первым аргументом метод `createElement`, нужный для создания `VNode`-ов.

    Если компонент функциональный, вторым параметром передаётся `context`, дающий доступ к контекстным данным, так как функциональные компоненты не имеют инстансов.

  - **См. также:**
    - [Render-функции](../guide/render-function)

## Опции — Хуки жизненного цикла

Контекст `this` хуков указывает на инстанс Vue c данными, вычисляемыми свойствами и методами. Это значит, что __вам не следует использовать arrow-функции для определения хуков жизненного цикла__ (напр. `created: () => this.fetchTodos()`). Поскольку arrow-функции связываются с родительским контекстом, `this` не будет указывать на инстанс Vue, и `this.fetchTodos` окажется неопределенным.

### beforeCreate

- **Тип:** `Function`

- **Подробности:**

  Вызывается синхронно сразу после инициализации инстанса, до настройки наблюдения за данными, механизмов слежения и событий.

- **См. также:** [Диаграмма жизненного цикла](../guide/instance.html#Диаграмма-жизненного-цикла)

### created

- **Тип:** `Function`

- **Подробности:**

  Вызывается синхронно сразу после создания инстанса. На этом этапе инстанс закончил обработку опций и настроил наблюдение за данными, вычисляемые свойства, методы, коллбэки слежения и событий. Однако, фаза монтирования ещё не начата, и свойство `$el` ещё не доступно.

- **См. также:** [Диаграмма жизненного цикла](../guide/instance.html#Диаграмма-жизненного-цикла)

### beforeMount

- **Тип:** `Function`

- **Подробности:**

  Вызывается перед началом монтирования, сразу перед первым вызовом функции `render`.

  **При рендере на стороне сервера этот хук не вызывается.**

- **См. также:** [Диаграмма жизненного цикла](../guide/instance.html#Диаграмма-жизненного-цикла)

### mounted

- **Тип:** `Function`

- **Подробности:**

  Вызывается сразу после того как инстанс был смонтирован, а взамен `el` создан `vm.$el`. Если корневой инстанс смонтирован на элемент документа, `vm.$el` тоже будет элементом документа.

  **При рендере на стороне сервера этот хук не вызывается.**

- **См. также:** [Диаграмма жизненного цикла](../guide/instance.html#Диаграмма-жизненного-цикла)

### beforeUpdate

- **Тип:** `Function`

- **Подробности:**

  Вызывается при изменении данных, до перерендера и обновления виртуального DOM-а.

  В этом хуке можно дополнительно изменять состояние, и это не вызовет нового перерендера.

  **При рендере на стороне сервера этот хук не вызывается.**

- **См. также:** [Диаграмма жизненного цикла](../guide/instance.html#Диаграмма-жизненного-цикла)

### updated

- **Тип:** `Function`

- **Подробности:**

  Вызывается после того, как виртуальный DOM был обновлён из-за изменения данных.

  DOM компонента уже будет обновлён к моменту вызова этого хука, поэтому можно выполнять зависящие от DOM операции. Старайтесь избегать изменения состояния в этом хуке, чтобы не попасть в бесконечный цикл обновления.

  **При рендере на стороне сервера этот хук не вызывается.**

- **См. также:** [Диаграмма жизненного цикла](../guide/instance.html#Диаграмма-жизненного-цикла)

### activated

- **Тип:** `Function`

- **Подробности:**

  Вызывается при активации keep-alive компонента.

  **При рендере на стороне сервера этот хук не вызывается.**

- **См. также:**
  - [Встроенные компоненты — keep-alive](#keep-alive)
  - [Динамические компоненты — keep-alive](../guide/components.html#keep-alive)

### deactivated

- **Тип:** `Function`

- **Подробности:**

  Вызывается после деактивации keep-alive компонента.

  **При рендере на стороне сервера этот хук не вызывается.**

- **См. также:**
  - [Встроенные компоненты - keep-alive](#keep-alive)
  - [Динамические компоненты - keep-alive](../guide/components.html#keep-alive)

### beforeDestroy

- **Тип:** `Function`

- **Подробности:**

  Вызывается перед уничтожением инстанса Vue. На этом этапе инстанс всё ещё полностью функционален.

  **При рендере на стороне сервера этот хук не вызывается.**

- **См. также:** [Диаграмма жизненного цикла](../guide/instance.html#Диаграмма-жизненного-цикла)

### destroyed

- **Тип:** `Function`

- **Подробности:**

  Вызывается после уничтожения инстанса Vue. К моменту вызова этого хука, все директивы инстанса Vue уже отвязаны, все подписчики событий удалены, а все дочерние инстансы Vue уничтожены.

  **При рендере на стороне сервера этот хук не вызывается.**

- **См. также:** [Диаграмма жизненного цикла](../guide/instance.html#Диаграмма-жизненного-цикла)

## Опции — ресурсы

### directives

- **Тип:** `Object`

- **Подробности:**

  Хэш директив, доступных инстансу Vue.

- **См. также:**
  - [Пользовательские директивы](../guide/custom-directive.html)
  - [Соглашение по именованию компонентов](../guide/components.html#Соглашения-по-именованию-компонентов)

### filters

- **Тип:** `Object`

- **Подробности:**

  Хэш фильтров, доступных инстансу Vue.

- **См. также:**
  - [`Vue.filter`](#Vue-filter)

### components

- **Тип:** `Object`

- **Подробности:**

  Хэш компонентов, доступных инстансу Vue.

- **См. также:**
  - [Компоненты](../guide/components.html)

## Опции — разное

### parent

- **Тип:** `инстанс Vue`

- **Подробности:**

  Указывает новому инстансу на родительский и устанавливает отношение "родитель-ребёнок" между ними. Родительский элемент будет доступен дочернему в `this.$parent`, а дочерний элемент будет добавлен в массив `$children` родителя.

  <p class="tip">Старайтесь реже использовать `$parent` и `$children` - этот механизм мы предусмотрели на крайний случай. Для общения между родителем и ребёнком лучше использовать свойства и события.</p>

### mixins

- **Тип:** `Array<Object>`

- **Подробности:**

  Массив объектов-миксинов. Миксины могут содержать те же опции, что и обычные объекты инстансов Vue — они будут добавлены к основным опциям согласно логике `Vue.extend()`. Например, если и миксин и объект оба содержат хук `created`, вызваны будут они оба.

  Хуки миксинов вызываются в порядке их определения, до вызова собственных хуков компонента.

- **Пример:**

  ``` js
  var mixin = {
    created: function () { console.log(1) }
  }
  var vm = new Vue({
    created: function () { console.log(2) },
    mixins: [mixin]
  })
  // -> 1
  // -> 2
  ```

- **См. также:** [Миксины](../guide/mixins.html)

### name

- **Тип:** `string`

- **Ограничение:** учитывается только при определении компонента.

- **Подробности:**

  Название компонента. Позволяет компоненту рекурсивно вызывать самого себя в шаблоне. Обратите внимание что когда компонент регистрируется глобально посредством `Vue.component()`, глобальный ID автоматически становится таким же, как и имя.

  Кроме того, компоненты с указанным `name` проще отлаживать из-за более понятных сообщений в консоли. В [vue-devtools](https://github.com/vuejs/vue-devtools) все безымянные компоненты довольно неинформативно называются `<AnonymousComponent>`. Когда у компонентов указано `name`, дерево компонентов становится куда понятнее.

### extends

- **Тип:** `Object | Function`

- **Подробности:**

  Позволяет декларативно наследоваться от другого компонента (который может быть либо простым объектом, либо конструктором), не используя `Vue.extend`. Главным образом предназначено для облегчения наследования между компонентами, определёнными в одном файле.

  Эта функциональность близка к `mixins`, с той разницей, что собственные опции компонента приоритетнее опций компонента, от которого происходит наследование.

- **Пример:**

  ``` js
  var CompA = { ... }

  // наследуем от CompA, не вызывая Vue.extend:
  var CompB = {
    extends: CompA,
    ...
  }
  ```

### delimiters

- **Тип:** `Array<string>`

- **по умолчанию:** `{% raw %}["{{", "}}"]{% endraw %}`

- **Подробности:**

  Маркеры, выделяющие текст для интерполяции. **Доступно только в автономной сборке.**

- **Пример:**

  ``` js
  // меняем маркеры в шаблонах на свойственные ES6:

  new Vue({
    delimiters: ['${', '}']
  })
  ```

### functional

- **Тип:** `boolean`

- **Подробности:**

  Превращает компонент в функциональный, то есть не имеющий собственного состояния (`data`) и своего инстанса (`this`). Такие компоненты по сути — просто функция `render`, возвращающая узлы виртуального DOM. Это сильно ускоряет их рендер.

- **См. также:** [Функциональные компоненты](../guide/render-function.html#Функциональные-компоненты)

## Свойства инстанса

### vm.$data

- **Тип:** `Object`

- **Подробности:**

  Объект с данными, над которым инстанс Vue осуществляет наблюдение. Инстанс проксирует сюда вызовы своих полей. (Например, `vm.a` будет указывать на `vm.$data.a`)

- **См. также:** [Опции — данные](#data)

### vm.$el

- **Тип:** `HTMLElement`

- **Только для чтения**

- **Подробности:**

  Корневой элемент DOM, управляемый инстансом Vue.

### vm.$options

- **Тип:** `Object`

- **Только для чтения**

- **Подробности:**

  Опции, переданные в конструктор инстанса Vue. Полезно, если вы хотите передавать туда собственные опции:

  ``` js
  new Vue({
    customOption: 'что-нибудь',
    created: function () {
      console.log(this.$options.customOption) // -> 'что-нибудь'
    }
  })
  ```

### vm.$parent

- **Тип:** `инстанс Vue`

- **Только для чтения**

- **Подробности:**

  Инстанс-родитель, если он задан.

### vm.$root

- **Тип:** `инстанс Vue`

- **Только для чтения**

- **Подробности:**

  Корневой инстанс Vue текущего дерева компонентов. Если у инстанса нет родителя, в этом поле будет он сам.

### vm.$children

- **Тип:** `Array<инстанс Vue>`

- **Только для чтения**

- **Подробности:**

  Компоненты-потомки инстанса. **Обратите внимание, что порядок следования элементов в `$children` не гарантируется, и этот массив не реактивен.** Вместо того, чтобы использовать `$children` для связывания данных, попробуйте использовать обычный массив и директиву `v-for` для создания дочерних компонент, и используйте этот массив как "источник истины".

### vm.$slots

- **Тип:** `Object`

- **Только для чтения**

- **Подробности:**

  Используется для доступа к контенту, [распространяемому слотами](../guide/components.html#Дистрибьюция-контента-через-слоты). У каждого [именованного слота](../guide/components.html#Именованные-слоты) есть соответствующее значение в хэше (например, содержимое `slot="foo"` попадёт в `vm.$slots.foo`). Свойство `default` содержит узлы, не включённые в именованные слоты.

  Особенно полезно `vm.$slots` в компонентах с [render-функциями](../guide/render-function.html).

- **Пример:**

  ```html
  <blog-post>
    <h1 slot="header">
      Обо мне
    </h1>

    <p>Этот контент попадёт в vm.$slots.default, потому что он не в именованном слоте.</p>

    <p slot="footer">
      Copyright 2016 Evan You
    </p>

    <p>Этот контент тоже попадёт в vm.$slots.default.</p>.
  </blog-post>
  ```

  ```js
  Vue.component('blog-post', {
    render: function (createElement) {
      var header = this.$slots.header
      var body   = this.$slots.default
      var footer = this.$slots.footer
      return createElement('div', [
        createElement('header', header)
        createElement('main', body)
        createElement('footer', footer)
      ])
    }
  })
  ```

- **См. также:**
  - [Компонент `<slot>`](#slot)
  - [Распределение контента через слоты](../guide/components.html#Дистрибьюция-контента-через-слоты)
  - [Render-функции](../guide/render-function.html)

### vm.$refs

- **Тип:** `Object`

- **Только для чтения**

- **Подробности:**

  Объект, с дочерними компонентами, имеющими параметр `ref`.

- **См. также:**
  - [Ссылки на дочерние компоненты](../guide/components.html#Ссылки-на-дочерние-компоненты)
  - [ref](#ref)

### vm.$isServer

- **Тип:** `boolean`

- **Только для чтения**

- **Подробности:**

  Запущен ли данный инстанс Vue на сервере.

- **См. также:** [Рендер на сервере](../guide/ssr.html)

## Методы инстанса — данные

<h3 id="vm-watch">vm.$watch( expOrFn, callback, [options] )</h3>

- **Аргументы:**
  - `{string | Function} expOrFn`
  - `{Function} callback`
  - `{Object} [options]`
    - `{boolean} deep`
    - `{boolean} immediate`

- **Возвращает:** `{Function} unwatch`

- **Использование:**

  Запускает слежение за выражением или вычисляемой функцией на предмет изменений. В параметры коллбэка будут переданы новые и старые значения отслеживаемого объекта. Выражение может быть только простым путём до переменной с разделителями-точками. Для более сложных случаев используйте функцию.

<p class="tip">Обратите внимание: когда мы изменяете (а не заменяете) объект или массив, старое и новое значения при вызове коллбэка будут совпадать, так как они ссылаются на один и тот же объект или массив. Vue не сохраняяет копии объекта на момент, предшествовавший изменениям.</p>

- **Пример:**

  ``` js
  // следим за переменной, указанной путём:
  vm.$watch('a.b.c', function (newVal, oldVal) {
    // переменная изменилась, сделайте что-нибудь
  })

  // следим за функцией:
  vm.$watch(
    function () {
      return this.a + this.b
    },
    function (newVal, oldVal) {
      // значение функции изменилось, сделайте что-нибудь
    }
  )
  ```

  `vm.$watch` возвращает функцию unwatch, которая останавливает слежение:

  ``` js
  var unwatch = vm.$watch('a', cb)
  // позднее, останавливаем слежение:
  unwatch()
  ```

- **Опция: deep**

  Чтобы слежение реагировало на изменения во вложенных объектах, передайте `deep: true` в параметре options. Обратите внимание, что для наблюдения за изменениями массивов этого не требуется.

  ``` js
  vm.$watch('someObject', callback, {
    deep: true
  })
  vm.someObject.nestedValue = 123
  // вызывается callback
  ```

- **Опция: immediate**

  Если передано `immediate: true`, коллбэк будет вызван сразу же после начала слежения с текущим значением выражения:

  ``` js
  vm.$watch('a', callback, {
    immediate: true
  })
  // callback вызывается сразу, с текущим значением `a`
  ```

<h3 id="vm-set">vm.$set( object, key, value )</h3>

- **Аргументы:**
  - `{Object} object`
  - `{string} key`
  - `{any} value`

- **Возвращает:** установленное значение.

- **Использование:**

  **Алиас** глобального метода `Vue.set`.

- **См. также:** [Vue.set](#Vue-set)

<h3 id="vm-delete">vm.$delete( object, key )</h3>

- **Аргументы:**
  - `{Object} object`
  - `{string} key`

- **Использование:**

  **Алиас** глобального метода `Vue.delete`.

- **См. также:** [Vue.delete](#Vue-delete)

## Методы инстанса — cобытия

<h3 id="vm-on">vm.$on( event, callback )</h3>

- **Аргументы:**
  - `{string} event`
  - `{Function} callback`

- **Использование:**

  Реагирует на пользовательское событие текущего vm. Такое событие можно вызвать функцией `vm.$emit`. Коллбэк получит все дополнительные аргументы, переданные этому методу.

- **Пример:**

  ``` js
  vm.$on('test', function (msg) {
    console.log(msg)
  })
  vm.$emit('test', 'привет')
  // -> "привет"
  ```

<h3 id="vm-once">vm.$once( event, callback )</h3>

- **Аргументы:**
  - `{string} event`
  - `{Function} callback`

- **Использование:**

  Реагирует на пользовательское событие один раз. После первого использования подписчик будет удалён.

<h3 id="vm-off">vm.$off( [event, callback] )</h3>

- **Аргументы:**
  - `{string} [event]`
  - `{Function} [callback]`

- **Использование:**

  Удаляет подписчика или подписчиков события.

  - Если функция вызвана без параметров, она удалит все подписки на события;

  - Если указан только тип события — удалит все подписки указанного события;

  - Если указан и тип события, и коллбэк — будет удалена именно эта подписка именно этого события.

<h3 id="vm-emit">vm.$emit( event, [...args] )</h3>

- **Аргументы:**
  - `{string} event`
  - `[...args]`

  Вызывает событие в текущем инстансе. Все дополнительно указанные параметры будут переданы в коллбэк подписки.

## Методы инстанса — жизненный цикл

<h3 id="vm-mount">vm.$mount( [elementOrSelector] )</h3>

- **Аргументы:**
  - `{Element | string} [elementOrSelector]`
  - `{boolean} [hydrating]`

- **Returns:** `vm` - сам инстанс

- **Использование:**

  Если при создании инстанса Vue не была указана опция `el`, он окажется в "непримонтированном" (unmounted) состоянии, то есть без ассоциированного элемента DOM. Вызовите `vm.$mount()`, чтобы примонтировать такой инстанс.

  Если параметр `elementOrSelector` не указан, шаблон будет отрендерен как элемент вне документа. Вы сможете затем вставить такой элемент нативным интерфейсом DOM.

  Метод возвращает сам инстанс, чтобы вы могли вызывать дополнительные методы по цепочке.

- **Пример:**

  ``` js
  var MyComponent = Vue.extend({
    template: '<div>Привет!</div>'
  })

  // создаём и монтируем в #app (заменит #app):
  new MyComponent().$mount('#app')

  // другой вариант записи, делает то же самое:
  new MyComponent({ el: '#app' })

  // рендерим вне документа и вставляем в DOM позднее:
  var component = new MyComponent().$mount()
  document.getElementById('app').appendChild(component.$el)
  ```

- **См. также:**
  - [Диаграмма жизненного цикла](../guide/instance.html#Диаграмма-жизненного-цикла)
  - [Рендер на сервере](../guide/ssr.html)

<h3 id="vm-forceUpdate">vm.$forceUpdate()</h3>

- **Использование:**

  Заставляет инстанс Vue произвести перерендер. Обратите внимание, что этот метод перерендерит не все дочерние компоненты, только сам инстанс и дочерние компоненты с контентными слотами.

<h3 id="vm-nextTick">vm.$nextTick( callback )</h3>

- **Аргументы:**
  - `{Function} callback`

- **Использование:**

  Выполняет функцию callback при следующем цикле обновления DOM. Вызывайте сразу после изменения данных, чтобы работать с обновлённым DOM. Функция делает то же самое, что и глобальный `Vue.nextTick`, но кроме того связывает `this` с текущим инстансом в коллбэке.

- **Пример:**

  ``` js
  new Vue({
    // ...
    methods: {
      // ...
      example: function () {
        // меняем данные:
        this.message = 'changed'
        // DOM ещё не обновлён
        this.$nextTick(function () {
          // теперь DOM обновлён
          // `this` указывает на текущий инстанс
          this.doSomethingElse()
        })
      }
    }
  })
  ```

- **См. также:**
  - [Vue.nextTick](#Vue-nextTick)
  - [Очередь асинхронных обновлений](../guide/reactivity.html#Асинхронная-очередь-обновлений)

<h3 id="vm-destroy">vm.$destroy()</h3>

- **Использование:**

  Полностью уничтожает vm. Очищает связи с другими существующими vm, отвязывает директивы, выключает все подписки на события.

  Вызывает хуки `beforeDestroy` и `destroyed`.

  <p class="tip">Как правило, вам не придётся вызывать этот метод самим. Лучше контролировать жизненный цикл дочерних компонентов в data-driven стиле директивами `v-if` и `v-for`.</p>

- **См. также:** [Диаграмма жизненного цикла](../guide/instance.html#Диаграмма-жизненного-цикла)

## Директивы

### v-text

- **Принимает:** `string`

- **Подробности:**

  Управляет текстовым содержимым элемента (`textContent`). Если вам нужно управлять только частью содержимого тега, используйте интерполяцию `{% raw %}{{ Mustache }}{% endraw %}`.

- **Пример:**

  ```html
  <span v-text="msg"></span>
  <!-- то же, что -->
  <span>{{msg}}</span>
  ```

- **См. также:** [Синтаксис связывания данных — интерполяции](../guide/syntax.html#Текст)

### v-html

- **Принимает:** `string`

- **Подробности:**

  Управляет html-содержимым элемента (`innerHTML`). **Обратите внимание, что содержимое вставляется как обычный HTML — то есть не компилируется как шаблон Vue**. Не стоит организовывать вложенные шаблоны с помощью `v-html`, попробуйте лучше применить компоненты.

  <p class="tip">Динамический рендер произвольного HTML-кода на сайте — это очень опасно, так как легко приводит к [XSS-атакам](https://en.wikipedia.org/wiki/Cross-site_scripting). Передавайте в `v-html` только доверенный код, **никогда** не передавайте сюда ничего, предоставленного пользователями.</p>

- **Пример:**

  ```html
  <div v-html="html"></div>
  ```
- **См. также:** [Синтаксис связывания данных — интерполяции](../guide/syntax.html#Сырой-HTML)

### v-if

- **Принимает:** `any`

- **Использование:**

  Если указанное значение истинное, рендерит элемент, а если ложное — не рендерит. Когда значение переключается, элемент и содержащиеся в нём компоненты с директивами уничтожаются или пересоздаются. Если элемент — `<template>`, вместо элемента будет отрендерено его содержимое. Это нужно, чтобы завернуть в один v-if несколько элементов сразу.

  При изменении состояния этой директивы вызываются анимации, заданные в transition.

- **См. также:** [Условный рендер - v-if](../guide/conditional.html)

### v-show

- **Принимает:** `any`

- **Использование:**

  Переключает CSS-свойство `display` элемента, в зависимости от того, истинно ли указанное выражение.

  При изменении состояния этой директивы вызываются анимации, заданные в transition.


- **См. также:** [Условный рендер — v-show](../guide/conditional.html#v-show)

### v-else

- **Не принимает какое-либо выражение**

- **Ограничение:** предыдущий элемент должен иметь директиву `v-if`.

- **Использование:**

  Определяет "блок else" для `v-if`.

  ```html
  <div v-if="Math.random() > 0.5">
    Сейчас меня видно
  </div>
  <div v-else>
    А сейчас — нет
  </div>
  ```

- **См. также:**
  - [Условный рендер — v-else](../guide/conditional.html#v-else)

### v-for

- **Принимает:** `Array | Object | number | string`

- **Использование:**

  Многократно рендерит элемент или блок шаблона, основываясь на переданных данных. Значение директивы должно следовать синтаксису `alias in expression` — в alias будет элемент текущей итерации:

  ``` html
  <div v-for="item in items">
    {{ item.text }}
  </div>
  ```

   Кроме того, вы можете указать название для индекса (или ключа, если вы работаете с хэшем):

  ``` html
  <div v-for="(item, index) in items"></div>
  <div v-for="(val, key) in object"></div>
  <div v-for="(val, key, index) in object"></div>
  ```

  По умолчанию `v-for` будет пытаться обновить элементы "на месте", не перемещая их. Если вам нужно, чтобы элементы перемещались, сохраняя явную упорядоченность, укажите атрибут `key`:

  ``` html
  <div v-for="item in items" :key="item.id">
    {{ item.text }}
  </div>
  ```

  Использование `v-for` подробно описано в секции руководства по ссылке ниже.

- **См. также:**
  - [Рендер списков](../guide/list.html)
  - [key](../guide/list.html#key)

### v-on

- **Сокращение:** `@`

- **Принимает:** `Function | Inline Statement`

- **Параметр:** `event (обязательный)`

- **Модификаторы:**
  - `.stop` - вызовет `event.stopPropagation()`.
  - `.prevent` - вызовет `event.preventDefault()`.
  - `.capture` - добавит подписку в режиме capture.
  - `.self` - вызовет обработчик только если событие возникло непосредственно на этом элементе.
  - `.{keyCode | keyAlias}` - вызывает обработчик только при нажатии определённой клавиши.
  - `.native` - подписаться на нативное событие на корневом элементе компонента.

- **Использование:**

  Прикрепляет к элементу подписчик события. Тип события указывается в параметре. Выражение может быть именем метода, inline-выражением или вовсе отсутствовать, если указан один или несколько модификаторов.

  У обычного элемента можно подписаться только **на нативные события DOM**. У элемента компонента можно также подписаться **на пользовательские события**, вызываемые этим дочерним компонентом.

  При работе с нативными событиями DOM, метод получает нативное событие единственным аргументом. В inline-выражениях, можно получить к нему доступ с помощью `$event`: `v-on:click="handle('ok', $event)"`.

- **Пример:**

  ```html
  <!-- обработчик метода -->
  <button v-on:click="doThis"></button>

  <!-- inline-выражение -->
  <button v-on:click="doThat('hello', $event)"></button>

  <!-- сокращенная запись -->
  <button @click="doThis"></button>

  <!-- модификатор stop propagation -->
  <button @click.stop="doThis"></button>

  <!-- модификатор prevent default -->
  <button @click.prevent="doThis"></button>

  <!-- модификатор prevent default без дополнительных действий -->
  <form @submit.prevent></form>

  <!-- цепочка из модификаторов -->
  <button @click.stop.prevent="doThis"></button>

  <!-- модификатор клавиши keyAlias -->
  <input @keyup.enter="onEnter">

  <!-- модификатор клавиши keyCode -->
  <input @keyup.13="onEnter">
  ```

  Подписка на пользовательское событие в дочернем элементе (обработчик вызывается, когда дочерний элемент вызывает "my-event"):

  ```html
  <my-component @my-event="handleThis"></my-component>

  <!-- inline-выражение -->
  <my-component @my-event="handleThis(123, $event)"></my-component>

  <!-- подписываемся на нативное событие в компоненте -->
  <my-component @click.native="onClick"></my-component>
  ```

- **См. также:**
  - [Методы и обработка событий](../guide/events.html)
  - [Компоненты — пользовательские события](../guide/components.html#Пользовательские-события)

### v-bind

- **Сокращение:** `:`

- **Принимает:** `any (если указан параметр) | Object (если параметр не указан)`

- **Параметр:** `attrOrProp (optional)`

- **Модификаторы:**
  - `.prop` - Используется для связывания DOM-аттрибутов.

- **Использование:**

  Динамически связывает атрибуты тега или входной параметр компонента с выражением.

  При использовании с атрибутами `class` и `style` поддерживает массивы и объекты в качестве значений. Подробнее это описано в соответствующем руководстве по ссылке ниже.

  Для правильного связывания входного параметра компонента, тот должен быть корректно определён в дочернем компоненте.

  Если аргумент не указан, связанное значение может быть содержащим пары имя-значение. Обратите внимание, что в этом случае атрибуты `class` и `style` не поддерживают массивы и объекты.

- **Пример:**

  ```html
  <!-- связывание атрибута -->
  <img v-bind:src="imageSrc">

  <!-- сокращение -->
  <img :src="imageSrc">

  <!-- связывание css-класса -->
  <div :class="{ red: isRed }"></div>
  <div :class="[classA, classB]"></div>
  <div :class="[classA, { classB: isB, classC: isC }]">

  <!-- связывание локального стиля -->
  <div :style="{ fontSize: size + 'px' }"></div>
  <div :style="[styleObjectA, styleObjectB]"></div>

  <!-- связывание с объектом, содержащим атрибуты -->
  <div v-bind="{ id: someProp, 'other-attr': otherProp }"></div>

  <!-- связывание с атрибутами DOM при указании модификатора -->
  <div v-bind:text-content.prop="text"></div>

  <!-- связывание входного параметра. "prop" должен быть определён в my-component. -->
  <my-component :prop="someThing"></my-component>

  <!-- XLink -->
  <svg><a :xlink:special="foo"></a></svg>
  ```

- **См. также:**
  - [Связывание классов и стилей](../guide/class-and-style.html)
  - [Компоненты — входные параметры компонентов](../guide/components.html#Входные-параметры)

### v-model

- **Принимает:** разное, в зависимости от типа форм или выходных данных компонентов

- **Используется только с:**
  - `<input>`
  - `<select>`
  - `<textarea>`
  - компонентами

- **Модификаторы:**
  - [`.lazy`](../guide/forms.html#lazy) - подписаться на события `change`, а не `input`
  - [`.number`](../guide/forms.html#number) - приводить введённую строку к числу
  - [`.trim`](../guild/forms.html#trim) - удалять пробелы в начале и в конце введённой строки

- **Использование:**

  Двусторонним образом связывает элемент ввода данных или компонент с переменной. Директива описана в руководстве по ссылке ниже.

- **См. также:**
  - [Связывание элементов ввода данных](../guide/forms.html)
  - [Компоненты — компоненты для ввода данных с пользовательскими событиями](../guide/components.html#Элементы-ввода-форм-и-пользовательские-события)

### v-pre

- **Не принимает какое-либо выражение**

- **Использование:**

  Пропустить компиляцию для этого элемента и всех его потомков. Вы можете использовать это для отображения необработанных тегов `{% raw %}{{}}{% endraw %}`. Кроме того, пропуск большого количества элементов может ускорить компиляцию.

- **Пример:**

  ```html
  <span v-pre>{{ эта часть не будет скомпилирована }}</span>
   ```

### v-cloak

- **Не принимает какое-либо выражение**

- **Использование:**

  Эта директива останется на элементе до тех пор, пока связанный с ним инстанс Vue не закончит компиляцию. Если добавить CSS-правило вроде `[v-clock] { display: none }`, этой директивой можно прятать нескомпилированные шаблоны до тех пор, пока инстанс Vue не будет готов.

- **Пример:**

  ```css
  [v-cloak] {
    display: none;
  }
  ```

  ```html
  <div v-cloak>
    {{ message }}
  </div>
  ```

  Элемент `<div>` не появится, пока компиляция не закончится.

### v-once

- **Не принимает какое-либо выражение**

- **Использование:**

  **Однократно** рендерит элемент или компонент. При перерендере он, а также все его потомки будут рассматриваться как статический контент и пропускаться. Это поможет увеличить производительность обновлений.

  ```html
  <!-- одиночный элемент -->
  <span v-once>Это никогда не изменится: {{msg}}</span>
  <!-- элемент содержит потомков -->
  <div v-once>
    <h1>comment</h1>
    <p>{{msg}}</p>
  </div>
  <!-- компонент -->
  <my-component v-once :comment="msg"></my-component>
  <!-- директива v-for -->
  <ul>
    <li v-for="i in list" v-once>{{i}}</li>
  </ul>
  ```

- **См. также:**
  - [Синтаксис связывания данных — интерполяции](../guide/syntax.html#Текст)
  - [Компоненты — дешёвые статические компоненты с v-once](../guide/components.html#Дешёвые-статические-компоненты-с-использованием-v-once)

## Специальные атрибуты

### key

- **Принимает:** `string`

  Атрибут key помогает алгоритму работы с виртуальным DOM определить, какие ноды соответствует какой строке данных. Если этот аттрибут не указан, Vue использует алгоритм, минимизирующий перемещение элементов и старается обновить и повторно использовать как можно больше элементов правильного типа "на местах". А если ключ указан, Vue изменяет порядок следования элементов, основываясь на изменении порядка ключей. Элементы, соответствующие ключам, которых больше нет, Vue всегда уничтожает.

  Потомки одного и того же общего родителя должны иметь **уникальные ключи**. Повторяющиеся ключи приведут к ошибкам при рендере.

  Как правило, используется в связке с `v-for`:

  ``` html
  <ul>
    <li v-for="item in items" :key="item.id">...</li>
  </ul>
  ```

  Можно также применить эту директиву, чтобы элемент всегда заменялся на новый, а не переиспользовался. Это может помочь, если вы хотите:

  - Быть уверенны, что все хуки жизненного цикла компонента будут вызваны
  - Запускать анимации (например, установленные в transition)

  Например:

  ``` html
  <transition>
    <span :key="text">{{ text }}</span>
  </transition>
  ```

  При изменении `text`, `<span>` всегда будет заменяться целиком, что спровоцирует вызов анимации.

### ref

- **Принимает:** `string`

  Название элемента или компонента для регистрации ссылки на него. В объекте `$refs` появится поле с названием из этого атрибута и значением: элементом DOM, если атрибут стоял на простом теге или инстансом компонента, если атрибут стоял на пользовательском компоненте:

  ``` html
  <!-- vm.$refs.p будет указывать на элемент DOM -->
  <p ref="p">hello</p>

  <!-- vm.$refs.child будет указывать на инстанс ChildComp -->
  <child-comp ref="child"></child-comp>
  ```

  При использовании на элементах/компонентах с `v-for`, регистрируется массив ссылок на элементы DOM или инстансы компонентов.

  Важное замечание о времени регистрации ссылок: поскольку ссылки создаются функцией render, вы не cможете использовать их при первичном рендере — на тот момент они ещё не существуют! Кроме того, объект `$refs` не является реактивным, поэтому не стоит пытаться использовать его в шаблонах для связывания данных.

- **См. также:** [Ссылки на дочерние компоненты](../guide/components.html#Ссылки-на-дочерние-компоненты)

### slot

- **Принимает:** `string`

  Используется в содержимом дочерних компонентов для указания того, к какому из именованных слотов принадлежит отмеченный контент.

  Подробнее описан в руководстве по ссылке ниже.

- **См. также:** [Именованные слоты](../guide/components.html#Именованные-слоты)

## Встроенные компоненты

### component

- **Входные параметры:**
  - `is` - string | ComponentDefinition | ComponentConstructor
  - `inline-template` - boolean

- **Использование:**

  "Метакомпонент" для рендера динамических компонентов. Настоящий компонент для рендера определяется параметром `is`:

  ```html
  <!-- динамический компонент, контроллируемый -->
  <!-- свойством vm `componentId`-->
  <component :is="componentId"></component>

  <!-- может также рендерить зарегистрированный или переданный параметром компонент -->
  <component :is="$options.components.child"></component>
  ```

- **См. также:** [Динамические компоненты](../guide/components.html#Динамическое-переключение-компонентов)

### transition

- **Входные параметры:**
  - `name` - string, Используется для автоматической генерации имён CSS-классов для анимаций. Например, `name: 'fade'` автоматически раскроется в `.fade-enter`, `.fade-enter-active` и т. д. Значение по умолчанию — `"v"`.
  - `appear` - boolean, Вызывать ли анимацию при первом рендере. По умолчанию `false`.
  - `css` - boolean, Применять ли CSS-классы. По умолчанию `true`. Если установить в `false`, будут вызываться только хуки JavaScript, зарегистрированные для событий компонента.
  - `type` - string, Указывает тип событий, с помощью которых определяется момент завершения анимации. Доступные значения: `"transition"` и `"animation"`. По умолчанию автоматически выбирается тип, задающий наибольшую продолжительность.
  - `mode` - string, Управляет порядком анимаций исчезновения и появления элементов. Доступные режимы `"out-in"` (сначала старый элемент исчезает, потом новый появляется) и `"in-out"` (сначала новый элемент появляется, потом исчезает старый). По умолчанию исчезновение и появление происходят одновременно.
  - `enter-class` - string
  - `leave-class` - string
  - `enter-active-class` - string
  - `leave-active-class` - string
  - `appear-class` - string
  - `appear-active-class` - string

- **События:**
  - `before-enter`
  - `enter`
  - `after-enter`
  - `before-leave`
  - `leave`
  - `after-leave`
  - `before-appear`
  - `appear`
  - `after-appear`

- **Использование:**

  Указывает анимацию перехода для **одного** элемента или компонента. `<transition>` не порождает дополнительного элемента DOM при рендере, и не отображается в иерархии компонентов в инспекторе. Этот компонент просто применяет поведение перехода к своему содержимому.

  ```html
  <!-- простой элемент -->
  <transition>
    <div v-if="ok">переключаемое содержимое</div>
  </transition>

  <!-- динамический компонент -->
  <transition name="fade" mode="out-in" appear>
    <component :is="view"></component>
  </transition>

  <!-- хук на событие -->
  <div id="transition-demo">
    <transition @after-enter="transitionComplete">
      <div v-show="ok">toggled content</div>
    </transition>
  </div>
  ```

  ``` js
  new Vue({
    ...
    methods: {
      transitionComplete: function (el) {
        // сделайте что-нибудь с переданным элементом DOM ...
      }
    }
    ...
  }).$mount('#transition-demo')
  ```

- **См. также:** [Анимации переходов: появление, исчезновение и списки](../guide/transitions.html)

### transition-group

- **Входные параметры:**
  - `tag` - string, по умолчанию используется `span`.
  - `move-class` - переопределяет CSS-класс, применяемый во время анимации перемещения.
  - те же атрибуты, что и у `<transition>` кроме `mode`.

- **События:**
  - те же, что и у `<transition>`.

- **Использование:**

  Указывает анимацию перехода для **нескольких** элементов или компонентов. `<transition-group>` превращается в реальный элемент DOM. По умолчанию для этого используется тег `<span>`, но можно указать любой другой в параметре `tag`.

  Обратите внимание, что каждый потомок `<transition-group>` должен иметь **уникальный key**, чтобы анимации работали корректно.

  Анимации перехода реализованы с помощью CSS-трансформаций. Когда позиция потомка изменилась после обновления, ему будет добавлен CSS-класс (автоматически сгенерированный из атрибута `name`, или же явно указанный в атрибуте `move-class`). Если после применения этого класса свойство `transform` можно будет анимировать, элемент будет с плавным переходом переведён туда, где он должен быть с помощью [техники FLIP](https://aerotwist.com/blog/flip-your-animations/).

  ```html
  <transition-group tag="ul" name="slide">
    <li v-for="item in items" :key="item.id">
      {{ item.text }}
    </li>
  </transition-group>
  ```

- **См. также:** [Анимации переходов: появление, исчезновение и списки](../guide/transitions.html)

### keep-alive

- **Использование:**

  Оберните динамические компоненты тегом `<keep-alive>`, чтобы кэшировать инстансы интерактивных компонентов вместо того, чтобы их уничтожать. Так же, как и `<transition>`, `<keep-alive>` — абстрактный компонент: при рендере он не превращается в элемент DOM, и не показывается в цепочке родителей компонента.

  Когда компонент, расположенный внутри `<keep-alive>` показывается или скрывается, вызываются его хуки жизненного цикла `activated` или `deactivated` соответственно.

  В основном используется для сохранения состояния компонента, чтобы избежать повторного рендера.

  ```html
  <!-- базовый вариант -->
  <keep-alive>
    <component :is="view"></component>
  </keep-alive>

  <!-- несколько потомков -->
  <keep-alive>
    <comp-a v-if="a > 1"></comp-a>
    <comp-b v-else></comp-b>
  </keep-alive>

  <!-- использование вместе с <transition> -->
  <transition>
    <keep-alive>
      <component :is="view"></component>
    </keep-alive>
  </transition>
  ```

  <p class="tip">`<keep-alive>` не работает с функциональными компонентами, так как у них отсутствуют инстансы.</p>

- **См. также:** [Динамические компоненты — keep-alive](../guide/components.html#keep-alive)

### slot

- **Входные параметры:**
  - `name` - string, Используется для именования слотов

- **Использование:**

  `<slot>` — элемент, чьё содержимое будет распределено в шаблон компонента. Сам элемент `<slot>` при рендере заменяется.

  Подробнее этот механизм описан в руководстве по ссылке ниже.

- **См. также:** [Распределение контента слотами](../guide/components.html#Дистрибьюция-контента-через-слоты)

## Интерфейс VNode

- Смотрите информацию об [объявлении классов VNode](https://github.com/vuejs/vue/blob/dev/src/core/vdom/vnode.js).

## Рендер на стороне сервера

- Смотрите [документацию пакета vue-server-renderer](https://github.com/vuejs/vue/tree/dev/packages/vue-server-renderer).
